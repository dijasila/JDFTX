<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JDFTx: core/BlasExtra.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="jdftx-55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">JDFTx
   &#160;<span id="projectnumber">1.7.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('BlasExtra_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">BlasExtra.h File Reference<div class="ingroups"><a class="el" href="group__Core.html">Core functionality</a> &raquo; <a class="el" href="group__Operators.html">Operator implementations</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Commonly used BLAS-like routines.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;gsl/gsl_cblas.h&gt;</code><br />
<code>#include &lt;cstdlib&gt;</code><br />
<code>#include &lt;cstdio&gt;</code><br />
<code>#include &lt;cfloat&gt;</code><br />
<code>#include &lt;<a class="el" href="scalar_8h.html">core/scalar.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="Thread_8h.html">core/Thread.h</a>&gt;</code><br />
<code>#include &lt;cublas_v2.h&gt;</code><br />
<code>#include &lt;cuda_runtime.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga60f1cf2483a1cf0031f237bb3e50c299"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga60f1cf2483a1cf0031f237bb3e50c299">callPref</a>(functionName)&#160;&#160;&#160;functionName##_gpu</td></tr>
<tr class="memdesc:ga60f1cf2483a1cf0031f237bb3e50c299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select between functionName and functionName_gpu for the CPU and GPU executables respectively. <br /></td></tr>
<tr class="separator:ga60f1cf2483a1cf0031f237bb3e50c299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de03654a575ed8fd0e64fd362057fc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>DECLARE_eblas_sum</b>(sumFunc,  sumStridedFunc)</td></tr>
<tr class="separator:a2de03654a575ed8fd0e64fd362057fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga16b2911192a4dd45990e8d3c8749bc3c"><td class="memTemplParams" colspan="2">template&lt;typename Ty , typename Tx &gt; </td></tr>
<tr class="memitem:ga16b2911192a4dd45990e8d3c8749bc3c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga16b2911192a4dd45990e8d3c8749bc3c">eblas_mul</a> (const int N, const Tx *X, const int incX, Ty *Y, const int incY)</td></tr>
<tr class="memdesc:ga16b2911192a4dd45990e8d3c8749bc3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated elementwise multiply Y *= X for arrays X, Y.  <a href="group__Operators.html#ga16b2911192a4dd45990e8d3c8749bc3c">More...</a><br /></td></tr>
<tr class="separator:ga16b2911192a4dd45990e8d3c8749bc3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6379a3d39a315ffa2dcf2c92477741b1"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga6379a3d39a315ffa2dcf2c92477741b1">eblas_dmul</a> (const int N, const double *X, const int incX, double *Y, const int incY)</td></tr>
<tr class="memdesc:ga6379a3d39a315ffa2dcf2c92477741b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="group__Operators.html#ga16b2911192a4dd45990e8d3c8749bc3c" title="Templated elementwise multiply Y *= X for arrays X, Y.">eblas_mul()</a> for double[] *= double[]. <br /></td></tr>
<tr class="separator:ga6379a3d39a315ffa2dcf2c92477741b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e0b6dcdf4b62d7e67e7317502673c20"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga6e0b6dcdf4b62d7e67e7317502673c20">eblas_zmul</a> (const int N, const <a class="el" href="structcomplex.html">complex</a> *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:ga6e0b6dcdf4b62d7e67e7317502673c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="group__Operators.html#ga16b2911192a4dd45990e8d3c8749bc3c" title="Templated elementwise multiply Y *= X for arrays X, Y.">eblas_mul()</a> for complex[] *= complex[]. <br /></td></tr>
<tr class="separator:ga6e0b6dcdf4b62d7e67e7317502673c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2140c951abf8544320da930a0ebd4548"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga2140c951abf8544320da930a0ebd4548">eblas_zmuld</a> (const int N, const double *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:ga2140c951abf8544320da930a0ebd4548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="group__Operators.html#ga16b2911192a4dd45990e8d3c8749bc3c" title="Templated elementwise multiply Y *= X for arrays X, Y.">eblas_mul()</a> for complex[] *= double[]. <br /></td></tr>
<tr class="separator:ga2140c951abf8544320da930a0ebd4548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee5e834dbcc79293125ffb0aa1b54a5e"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaee5e834dbcc79293125ffb0aa1b54a5e">eblas_dmul_gpu</a> (const int N, const double *X, const int incX, double *Y, const int incY)</td></tr>
<tr class="memdesc:gaee5e834dbcc79293125ffb0aa1b54a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga6379a3d39a315ffa2dcf2c92477741b1" title="Specialization of eblas_mul() for double[] *= double[].">eblas_dmul()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:gaee5e834dbcc79293125ffb0aa1b54a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ef44b279657aad37389393e3f03ed6d"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga3ef44b279657aad37389393e3f03ed6d">eblas_zmul_gpu</a> (const int N, const <a class="el" href="structcomplex.html">complex</a> *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:ga3ef44b279657aad37389393e3f03ed6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga6e0b6dcdf4b62d7e67e7317502673c20" title="Specialization of eblas_mul() for complex[] *= complex[].">eblas_zmul()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga3ef44b279657aad37389393e3f03ed6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc467ff9f0a44f8eace7f68d5391ccc8"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gabc467ff9f0a44f8eace7f68d5391ccc8">eblas_zmuld_gpu</a> (const int N, const double *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:gabc467ff9f0a44f8eace7f68d5391ccc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga2140c951abf8544320da930a0ebd4548" title="Specialization of eblas_mul() for complex[] *= double[].">eblas_zmuld()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:gabc467ff9f0a44f8eace7f68d5391ccc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d7f3fb6cf181094d3969a28f2d661f1"><td class="memTemplParams" colspan="2">template&lt;typename Ty , typename Tx &gt; </td></tr>
<tr class="memitem:ga8d7f3fb6cf181094d3969a28f2d661f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga8d7f3fb6cf181094d3969a28f2d661f1">eblas_div</a> (const int N, const Tx *X, const int incX, Ty *Y, const int incY)</td></tr>
<tr class="memdesc:ga8d7f3fb6cf181094d3969a28f2d661f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated elementwise divide Y /= X for arrays X, Y.  <a href="group__Operators.html#ga8d7f3fb6cf181094d3969a28f2d661f1">More...</a><br /></td></tr>
<tr class="separator:ga8d7f3fb6cf181094d3969a28f2d661f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab632432b443a6e1569bd0d35b2b9d875"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gab632432b443a6e1569bd0d35b2b9d875">eblas_ddiv</a> (const int N, const double *X, const int incX, double *Y, const int incY)</td></tr>
<tr class="memdesc:gab632432b443a6e1569bd0d35b2b9d875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="group__Operators.html#ga8d7f3fb6cf181094d3969a28f2d661f1" title="Templated elementwise divide Y /= X for arrays X, Y.">eblas_div()</a> for double[] /= double[]. <br /></td></tr>
<tr class="separator:gab632432b443a6e1569bd0d35b2b9d875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a317f91a1c555cc4e57686a68fce61a"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga5a317f91a1c555cc4e57686a68fce61a">eblas_zdiv</a> (const int N, const <a class="el" href="structcomplex.html">complex</a> *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:ga5a317f91a1c555cc4e57686a68fce61a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="group__Operators.html#ga8d7f3fb6cf181094d3969a28f2d661f1" title="Templated elementwise divide Y /= X for arrays X, Y.">eblas_div()</a> for <a class="el" href="structcomplex.html" title="Complex number (need to define our own because we need operators for gpu code as well)">complex</a>[] /= <a class="el" href="structcomplex.html" title="Complex number (need to define our own because we need operators for gpu code as well)">complex</a>[]. <br /></td></tr>
<tr class="separator:ga5a317f91a1c555cc4e57686a68fce61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d1d01b5955a584591c77bf491648d10"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga4d1d01b5955a584591c77bf491648d10">eblas_zdivd</a> (const int N, const double *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:ga4d1d01b5955a584591c77bf491648d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="group__Operators.html#ga8d7f3fb6cf181094d3969a28f2d661f1" title="Templated elementwise divide Y /= X for arrays X, Y.">eblas_div()</a> for <a class="el" href="structcomplex.html" title="Complex number (need to define our own because we need operators for gpu code as well)">complex</a>[] /= double[]. <br /></td></tr>
<tr class="separator:ga4d1d01b5955a584591c77bf491648d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b56254d2d085b314f397614431d9be8"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga6b56254d2d085b314f397614431d9be8">eblas_ddiv_gpu</a> (const int N, const double *X, const int incX, double *Y, const int incY)</td></tr>
<tr class="memdesc:ga6b56254d2d085b314f397614431d9be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#gab632432b443a6e1569bd0d35b2b9d875" title="Specialization of eblas_div() for double[] /= double[].">eblas_ddiv()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga6b56254d2d085b314f397614431d9be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90dc7695ae5fa193758cf1dd1167cef2"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga90dc7695ae5fa193758cf1dd1167cef2">eblas_zdiv_gpu</a> (const int N, const <a class="el" href="structcomplex.html">complex</a> *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:ga90dc7695ae5fa193758cf1dd1167cef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga5a317f91a1c555cc4e57686a68fce61a" title="Specialization of eblas_div() for complex[] /= complex[].">eblas_zdiv()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga90dc7695ae5fa193758cf1dd1167cef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38da349ef7eb56da44c850ce79513abd"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga38da349ef7eb56da44c850ce79513abd">eblas_zdivd_gpu</a> (const int N, const double *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:ga38da349ef7eb56da44c850ce79513abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga4d1d01b5955a584591c77bf491648d10" title="Specialization of eblas_div() for complex[] /= double[].">eblas_zdivd()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga38da349ef7eb56da44c850ce79513abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe47cd65bab7057a60eea6d75b065281"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gafe47cd65bab7057a60eea6d75b065281">eblas_sumStrided</a> (const int N, const int stride, const double *X, double *result)</td></tr>
<tr class="memdesc:gafe47cd65bab7057a60eea6d75b065281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return sum over array of doubles with specified stride. <br /></td></tr>
<tr class="separator:gafe47cd65bab7057a60eea6d75b065281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81e1949388c17af1f3a06480413c7380"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga81e1949388c17af1f3a06480413c7380">eblas_sumStrided_gpu</a> (const int N, const int stride, const double *X, double *result)</td></tr>
<tr class="memdesc:ga81e1949388c17af1f3a06480413c7380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#gafe47cd65bab7057a60eea6d75b065281" title="Return sum over array of doubles with specified stride.">eblas_sumStrided()</a> for X on GPU; result is on CPU. <br /></td></tr>
<tr class="separator:ga81e1949388c17af1f3a06480413c7380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19cd74e6a9a5958b2760ec024c2aa04d"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga19cd74e6a9a5958b2760ec024c2aa04d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga19cd74e6a9a5958b2760ec024c2aa04d">eblas_sum</a> (const int N, const T *X)</td></tr>
<tr class="memdesc:ga19cd74e6a9a5958b2760ec024c2aa04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return sum over array of generic type T composed only of a certain number of double members. <br /></td></tr>
<tr class="separator:ga19cd74e6a9a5958b2760ec024c2aa04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47a40a1408d6f741288c098ff5233295"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga47a40a1408d6f741288c098ff5233295"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga47a40a1408d6f741288c098ff5233295">eblas_sum_gpu</a> (const int N, const T *X)</td></tr>
<tr class="memdesc:ga47a40a1408d6f741288c098ff5233295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga19cd74e6a9a5958b2760ec024c2aa04d" title="Return sum over array of generic type T composed only of a certain number of double members.">eblas_sum()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga47a40a1408d6f741288c098ff5233295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77f427ab61421ff49e1a5e3f2e4bd5ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga77f427ab61421ff49e1a5e3f2e4bd5ab">eblas_lincomb</a> (const int N, const <a class="el" href="structcomplex.html">complex</a> &amp;sX, const <a class="el" href="structcomplex.html">complex</a> *X, const int incX, const <a class="el" href="structcomplex.html">complex</a> &amp;sY, const <a class="el" href="structcomplex.html">complex</a> *Y, const int incY, <a class="el" href="structcomplex.html">complex</a> *Z, const int incZ)</td></tr>
<tr class="memdesc:ga77f427ab61421ff49e1a5e3f2e4bd5ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise linear combination Z = sX * X + sY * Y.  <a href="group__Operators.html#ga77f427ab61421ff49e1a5e3f2e4bd5ab">More...</a><br /></td></tr>
<tr class="separator:ga77f427ab61421ff49e1a5e3f2e4bd5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d58c4fae414cd9011e7f50d8943b6fc"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga8d58c4fae414cd9011e7f50d8943b6fc">eblas_lincomb_gpu</a> (const int N, const <a class="el" href="structcomplex.html">complex</a> &amp;sX, const <a class="el" href="structcomplex.html">complex</a> *X, const int incX, const <a class="el" href="structcomplex.html">complex</a> &amp;sY, const <a class="el" href="structcomplex.html">complex</a> *Y, const int incY, <a class="el" href="structcomplex.html">complex</a> *Z, const int incZ)</td></tr>
<tr class="memdesc:ga8d58c4fae414cd9011e7f50d8943b6fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga77f427ab61421ff49e1a5e3f2e4bd5ab" title="Elementwise linear combination Z = sX * X + sY * Y.">eblas_lincomb()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga8d58c4fae414cd9011e7f50d8943b6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bd2a68d44d54ff9cc6547fcd15baf8a"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga2bd2a68d44d54ff9cc6547fcd15baf8a">eblas_zgemm</a> (CBLAS_TRANSPOSE TransA, CBLAS_TRANSPOSE TransB, int M, int N, int K, const <a class="el" href="structcomplex.html">complex</a> &amp;alpha, const <a class="el" href="structcomplex.html">complex</a> *A, const int lda, const <a class="el" href="structcomplex.html">complex</a> *B, const int ldb, const <a class="el" href="structcomplex.html">complex</a> &amp;beta, <a class="el" href="structcomplex.html">complex</a> *C, const int ldc)</td></tr>
<tr class="memdesc:ga2bd2a68d44d54ff9cc6547fcd15baf8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threaded complex matrix multiply (threaded wrapper around zgemm) All the parameters have the same meaning as in cblas_zgemm, except element order is always Column Major (FORTRAN order!) <br /></td></tr>
<tr class="separator:ga2bd2a68d44d54ff9cc6547fcd15baf8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0586fe5f4eadb75205bad2eeaecd224c"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga0586fe5f4eadb75205bad2eeaecd224c">eblas_zgemm_gpu</a> (CBLAS_TRANSPOSE TransA, CBLAS_TRANSPOSE TransB, int M, int N, int K, const <a class="el" href="structcomplex.html">complex</a> &amp;alpha, const <a class="el" href="structcomplex.html">complex</a> *A, const int lda, const <a class="el" href="structcomplex.html">complex</a> *B, const int ldb, const <a class="el" href="structcomplex.html">complex</a> &amp;beta, <a class="el" href="structcomplex.html">complex</a> *C, const int ldc)</td></tr>
<tr class="memdesc:ga0586fe5f4eadb75205bad2eeaecd224c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap cublasZgemm to provide the same interface as <a class="el" href="group__Operators.html#ga2bd2a68d44d54ff9cc6547fcd15baf8a" title="Threaded complex matrix multiply (threaded wrapper around zgemm) All the parameters have the same mea...">eblas_zgemm()</a> <br /></td></tr>
<tr class="separator:ga0586fe5f4eadb75205bad2eeaecd224c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6920f2c3375ac67c6baf1af5c8043063"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga6920f2c3375ac67c6baf1af5c8043063">eblas_scatter_zdaxpy</a> (const int Nindex, double a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjx=false, const <a class="el" href="structcomplex.html">complex</a> *w=0, bool conjw=false)</td></tr>
<tr class="memdesc:ga6920f2c3375ac67c6baf1af5c8043063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter y(index) += a * x.  <a href="group__Operators.html#ga6920f2c3375ac67c6baf1af5c8043063">More...</a><br /></td></tr>
<tr class="separator:ga6920f2c3375ac67c6baf1af5c8043063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8401f2eef0fc7b6b7aa22066a82bf3c1"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga8401f2eef0fc7b6b7aa22066a82bf3c1">eblas_scatter_zaxpy</a> (const int Nindex, <a class="el" href="structcomplex.html">complex</a> a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjx=false, const <a class="el" href="structcomplex.html">complex</a> *w=0, bool conjw=false)</td></tr>
<tr class="memdesc:ga8401f2eef0fc7b6b7aa22066a82bf3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga6920f2c3375ac67c6baf1af5c8043063" title="Scatter y(index) += a * x.">eblas_scatter_zdaxpy()</a> with a complex scale factor. <br /></td></tr>
<tr class="separator:ga8401f2eef0fc7b6b7aa22066a82bf3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2ba4babf1d2cbf1ab787c8c33c5ee91"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gad2ba4babf1d2cbf1ab787c8c33c5ee91">eblas_scatter_daxpy</a> (const int Nindex, double a, const int *index, const double *x, double *y, const double *w=0)</td></tr>
<tr class="memdesc:gad2ba4babf1d2cbf1ab787c8c33c5ee91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga6920f2c3375ac67c6baf1af5c8043063" title="Scatter y(index) += a * x.">eblas_scatter_zdaxpy()</a> for real data arrays. <br /></td></tr>
<tr class="separator:gad2ba4babf1d2cbf1ab787c8c33c5ee91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga749e567418ffb3a1c3b9de6774eeb493"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga749e567418ffb3a1c3b9de6774eeb493">eblas_gather_zdaxpy</a> (const int Nindex, double a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjx=false, const <a class="el" href="structcomplex.html">complex</a> *w=0, bool conjw=false)</td></tr>
<tr class="memdesc:ga749e567418ffb3a1c3b9de6774eeb493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather y += a * x(index)  <a href="group__Operators.html#ga749e567418ffb3a1c3b9de6774eeb493">More...</a><br /></td></tr>
<tr class="separator:ga749e567418ffb3a1c3b9de6774eeb493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a97b86d5b2ab21d4d1fb918f13f3cc9"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga2a97b86d5b2ab21d4d1fb918f13f3cc9">eblas_gather_zaxpy</a> (const int Nindex, <a class="el" href="structcomplex.html">complex</a> a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjx=false, const <a class="el" href="structcomplex.html">complex</a> *w=0, bool conjw=false)</td></tr>
<tr class="memdesc:ga2a97b86d5b2ab21d4d1fb918f13f3cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga749e567418ffb3a1c3b9de6774eeb493" title="Gather y += a * x(index)">eblas_gather_zdaxpy()</a> with a complex scale factor. <br /></td></tr>
<tr class="separator:ga2a97b86d5b2ab21d4d1fb918f13f3cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cbc123f1c40b70689d154c73817736a"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga3cbc123f1c40b70689d154c73817736a">eblas_gather_daxpy</a> (const int Nindex, double a, const int *index, const double *x, double *y, const double *w=0)</td></tr>
<tr class="memdesc:ga3cbc123f1c40b70689d154c73817736a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga6920f2c3375ac67c6baf1af5c8043063" title="Scatter y(index) += a * x.">eblas_scatter_zdaxpy()</a> for real data arrays. <br /></td></tr>
<tr class="separator:ga3cbc123f1c40b70689d154c73817736a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dd3623c1986cc3347b38d084d9a9e71"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga3dd3623c1986cc3347b38d084d9a9e71">eblas_scatter_zdaxpy_gpu</a> (const int Nindex, double a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjx=false, const <a class="el" href="structcomplex.html">complex</a> *w=0, bool conjw=false)</td></tr>
<tr class="memdesc:ga3dd3623c1986cc3347b38d084d9a9e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga6920f2c3375ac67c6baf1af5c8043063" title="Scatter y(index) += a * x.">eblas_scatter_zdaxpy()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga3dd3623c1986cc3347b38d084d9a9e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab777fea35e9b776432add8df3f2ff2f7"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gab777fea35e9b776432add8df3f2ff2f7">eblas_scatter_zaxpy_gpu</a> (const int Nindex, <a class="el" href="structcomplex.html">complex</a> a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjx=false, const <a class="el" href="structcomplex.html">complex</a> *w=0, bool conjw=false)</td></tr>
<tr class="memdesc:gab777fea35e9b776432add8df3f2ff2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga8401f2eef0fc7b6b7aa22066a82bf3c1" title="Equivalent of eblas_scatter_zdaxpy() with a complex scale factor.">eblas_scatter_zaxpy()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:gab777fea35e9b776432add8df3f2ff2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13b559e3aa3e1a00e892f19102140cbd"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga13b559e3aa3e1a00e892f19102140cbd">eblas_scatter_daxpy_gpu</a> (const int Nindex, double a, const int *index, const double *x, double *y, const double *w=0)</td></tr>
<tr class="memdesc:ga13b559e3aa3e1a00e892f19102140cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#gad2ba4babf1d2cbf1ab787c8c33c5ee91" title="Equivalent of eblas_scatter_zdaxpy() for real data arrays.">eblas_scatter_daxpy()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga13b559e3aa3e1a00e892f19102140cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bcee46d09c50792e323bd2e6024d3a5"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga5bcee46d09c50792e323bd2e6024d3a5">eblas_gather_zdaxpy_gpu</a> (const int Nindex, double a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjx=false, const <a class="el" href="structcomplex.html">complex</a> *w=0, bool conjw=false)</td></tr>
<tr class="memdesc:ga5bcee46d09c50792e323bd2e6024d3a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga749e567418ffb3a1c3b9de6774eeb493" title="Gather y += a * x(index)">eblas_gather_zdaxpy()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga5bcee46d09c50792e323bd2e6024d3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga577e87716bb8bb527693f6a7832f2d7f"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga577e87716bb8bb527693f6a7832f2d7f">eblas_gather_zaxpy_gpu</a> (const int Nindex, <a class="el" href="structcomplex.html">complex</a> a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjx=false, const <a class="el" href="structcomplex.html">complex</a> *w=0, bool conjw=false)</td></tr>
<tr class="memdesc:ga577e87716bb8bb527693f6a7832f2d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga2a97b86d5b2ab21d4d1fb918f13f3cc9" title="Equivalent of eblas_gather_zdaxpy() with a complex scale factor.">eblas_gather_zaxpy()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga577e87716bb8bb527693f6a7832f2d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e81fcb0406e3cac6c632fe90f4740ac"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga4e81fcb0406e3cac6c632fe90f4740ac">eblas_gather_daxpy_gpu</a> (const int Nindex, double a, const int *index, const double *x, double *y, const double *w=0)</td></tr>
<tr class="memdesc:ga4e81fcb0406e3cac6c632fe90f4740ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga3cbc123f1c40b70689d154c73817736a" title="Equivalent of eblas_scatter_zdaxpy() for real data arrays.">eblas_gather_daxpy()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga4e81fcb0406e3cac6c632fe90f4740ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c1b03241b133beaed04728d26a086e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga6c1b03241b133beaed04728d26a086e3">eblas_accumNorm</a> (int N, const double &amp;a, const <a class="el" href="structcomplex.html">complex</a> *x, double *y)</td></tr>
<tr class="memdesc:ga6c1b03241b133beaed04728d26a086e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate elementwise norm of a complex array x into y i.e. y += a x conj(x)  <a href="group__Operators.html#ga6c1b03241b133beaed04728d26a086e3">More...</a><br /></td></tr>
<tr class="separator:ga6c1b03241b133beaed04728d26a086e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e140105e5e7ee1f8baaff4e6a016bf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga1e140105e5e7ee1f8baaff4e6a016bf5">eblas_accumProd</a> (int N, const double &amp;a, const <a class="el" href="structcomplex.html">complex</a> *xU, const <a class="el" href="structcomplex.html">complex</a> *xC, double *yRe, double *yIm)</td></tr>
<tr class="memdesc:ga1e140105e5e7ee1f8baaff4e6a016bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate elementwise product of two complex arrays xU and xC into real and imaginary parts yRe and yIm i.e. (yRe + i yIm) += a xU conj(xC)  <a href="group__Operators.html#ga1e140105e5e7ee1f8baaff4e6a016bf5">More...</a><br /></td></tr>
<tr class="separator:ga1e140105e5e7ee1f8baaff4e6a016bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf54b09ce097bfea9cfa343e2040c9bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gacf54b09ce097bfea9cfa343e2040c9bd">eblas_accumProdComplex</a> (int N, const double &amp;a, const <a class="el" href="structcomplex.html">complex</a> *xU, const <a class="el" href="structcomplex.html">complex</a> *xC, <a class="el" href="structcomplex.html">complex</a> *y)</td></tr>
<tr class="memdesc:gacf54b09ce097bfea9cfa343e2040c9bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate elementwise product of two complex arrays xU and xC into y.  <a href="group__Operators.html#gacf54b09ce097bfea9cfa343e2040c9bd">More...</a><br /></td></tr>
<tr class="separator:gacf54b09ce097bfea9cfa343e2040c9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4990759337c29d9752c444b78e3930db"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga4990759337c29d9752c444b78e3930db">eblas_accumNorm_gpu</a> (int N, const double &amp;a, const <a class="el" href="structcomplex.html">complex</a> *x, double *y)</td></tr>
<tr class="memdesc:ga4990759337c29d9752c444b78e3930db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga6c1b03241b133beaed04728d26a086e3" title="Accumulate elementwise norm of a complex array x into y i.e. y += a x conj(x)">eblas_accumNorm()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga4990759337c29d9752c444b78e3930db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25e99d5e1c919ea332e5232c4ddf7258"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga25e99d5e1c919ea332e5232c4ddf7258">eblas_accumProd_gpu</a> (int N, const double &amp;a, const <a class="el" href="structcomplex.html">complex</a> *xU, const <a class="el" href="structcomplex.html">complex</a> *xC, double *yRe, double *yIm)</td></tr>
<tr class="memdesc:ga25e99d5e1c919ea332e5232c4ddf7258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga1e140105e5e7ee1f8baaff4e6a016bf5" title="Accumulate elementwise product of two complex arrays xU and xC into real and imaginary parts yRe and ...">eblas_accumProd()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga25e99d5e1c919ea332e5232c4ddf7258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga551a0d0d63dda5c0df121deeb6183d0f"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga551a0d0d63dda5c0df121deeb6183d0f">eblas_accumProdComplex_gpu</a> (int N, const double &amp;a, const <a class="el" href="structcomplex.html">complex</a> *xU, const <a class="el" href="structcomplex.html">complex</a> *xC, <a class="el" href="structcomplex.html">complex</a> *y)</td></tr>
<tr class="memdesc:ga551a0d0d63dda5c0df121deeb6183d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga1e140105e5e7ee1f8baaff4e6a016bf5" title="Accumulate elementwise product of two complex arrays xU and xC into real and imaginary parts yRe and ...">eblas_accumProd()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga551a0d0d63dda5c0df121deeb6183d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d2cefdcc0e49ab0781fab0609ef5d74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga9d2cefdcc0e49ab0781fab0609ef5d74">eblas_symmetrize</a> (int N, int n, const int *symmIndex, double *x)</td></tr>
<tr class="memdesc:ga9d2cefdcc0e49ab0781fab0609ef5d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symmetrize an array x, using N n-fold equivalence classes in symmIndex.  <a href="group__Operators.html#ga9d2cefdcc0e49ab0781fab0609ef5d74">More...</a><br /></td></tr>
<tr class="separator:ga9d2cefdcc0e49ab0781fab0609ef5d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0c011b9e8e8f8086690068bcfa7ca92"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaa0c011b9e8e8f8086690068bcfa7ca92">eblas_symmetrize</a> (int N, int n, const int *symmIndex, <a class="el" href="structcomplex.html">complex</a> *x)</td></tr>
<tr class="memdesc:gaa0c011b9e8e8f8086690068bcfa7ca92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga9d2cefdcc0e49ab0781fab0609ef5d74" title="Symmetrize an array x, using N n-fold equivalence classes in symmIndex.">eblas_symmetrize()</a> for complex data pointers. <br /></td></tr>
<tr class="separator:gaa0c011b9e8e8f8086690068bcfa7ca92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae81ee89ce9455db6d3a33ed7d85dea5"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaae81ee89ce9455db6d3a33ed7d85dea5">eblas_symmetrize_gpu</a> (int N, int n, const int *symmIndex, double *x)</td></tr>
<tr class="memdesc:gaae81ee89ce9455db6d3a33ed7d85dea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga9d2cefdcc0e49ab0781fab0609ef5d74" title="Symmetrize an array x, using N n-fold equivalence classes in symmIndex.">eblas_symmetrize()</a> for real GPU data pointers. <br /></td></tr>
<tr class="separator:gaae81ee89ce9455db6d3a33ed7d85dea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a72763dcf3012ff1978f77c9f569ce8"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga5a72763dcf3012ff1978f77c9f569ce8">eblas_symmetrize_gpu</a> (int N, int n, const int *symmIndex, <a class="el" href="structcomplex.html">complex</a> *x)</td></tr>
<tr class="memdesc:ga5a72763dcf3012ff1978f77c9f569ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga9d2cefdcc0e49ab0781fab0609ef5d74" title="Symmetrize an array x, using N n-fold equivalence classes in symmIndex.">eblas_symmetrize()</a> for complex GPU data pointers. <br /></td></tr>
<tr class="separator:ga5a72763dcf3012ff1978f77c9f569ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae73590ae7d8bc5430e35a0eca6590b09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gae73590ae7d8bc5430e35a0eca6590b09">eblas_symmetrize</a> (int N, int n, const int *symmIndex, const int *symmMult, const <a class="el" href="structcomplex.html">complex</a> *phase, <a class="el" href="structcomplex.html">complex</a> *x)</td></tr>
<tr class="memdesc:gae73590ae7d8bc5430e35a0eca6590b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symmetrize a complex array x with phase factors, using N n-fold equivalence classes in symmIndex (useful for space group symmetrization in reciprocal space)  <a href="group__Operators.html#gae73590ae7d8bc5430e35a0eca6590b09">More...</a><br /></td></tr>
<tr class="separator:gae73590ae7d8bc5430e35a0eca6590b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a426fdd52157c7d1a984f5d2c4876c8"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga8a426fdd52157c7d1a984f5d2c4876c8">eblas_symmetrize_gpu</a> (int N, int n, const int *symmIndex, const int *symmMult, const <a class="el" href="structcomplex.html">complex</a> *phase, <a class="el" href="structcomplex.html">complex</a> *x)</td></tr>
<tr class="memdesc:ga8a426fdd52157c7d1a984f5d2c4876c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga9d2cefdcc0e49ab0781fab0609ef5d74" title="Symmetrize an array x, using N n-fold equivalence classes in symmIndex.">eblas_symmetrize()</a> for complex GPU data pointers. <br /></td></tr>
<tr class="separator:ga8a426fdd52157c7d1a984f5d2c4876c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a00682eceae2e0e80fd1d3a3fea409b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga1a00682eceae2e0e80fd1d3a3fea409b">eblas_symmetrize</a> (int N, int n, const int *symmIndex, const int *symmMult, const <a class="el" href="structcomplex.html">complex</a> *phase, const <a class="el" href="classmatrix3.html">matrix3</a>&lt;&gt; *rotSpin, std::vector&lt; <a class="el" href="structcomplex.html">complex</a> * &gt; x)</td></tr>
<tr class="memdesc:ga1a00682eceae2e0e80fd1d3a3fea409b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symmetrize a quadruplet of complex arrays with phase factors, using N n-fold equivalence classes in symmIndex (useful for space group symmetrization of spin density matrices in reciprocal space)  <a href="group__Operators.html#ga1a00682eceae2e0e80fd1d3a3fea409b">More...</a><br /></td></tr>
<tr class="separator:ga1a00682eceae2e0e80fd1d3a3fea409b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2eb5564b322ca31807d8322f4baec415"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga2eb5564b322ca31807d8322f4baec415">eblas_symmetrize_gpu</a> (int N, int n, const int *symmIndex, const int *symmMult, const <a class="el" href="structcomplex.html">complex</a> *phase, const <a class="el" href="classmatrix3.html">matrix3</a>&lt;&gt; *rotSpin, std::vector&lt; <a class="el" href="structcomplex.html">complex</a> * &gt; x)</td></tr>
<tr class="memdesc:ga2eb5564b322ca31807d8322f4baec415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga9d2cefdcc0e49ab0781fab0609ef5d74" title="Symmetrize an array x, using N n-fold equivalence classes in symmIndex.">eblas_symmetrize()</a> for complex GPU data pointers. <br /></td></tr>
<tr class="separator:ga2eb5564b322ca31807d8322f4baec415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e6f244886dd30b195522884c18637f2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3e6f244886dd30b195522884c18637f2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga3e6f244886dd30b195522884c18637f2">eblas_copy</a> (T *dest, const T *src, int N)</td></tr>
<tr class="memdesc:ga3e6f244886dd30b195522884c18637f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a data array.  <a href="group__Operators.html#ga3e6f244886dd30b195522884c18637f2">More...</a><br /></td></tr>
<tr class="separator:ga3e6f244886dd30b195522884c18637f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86241e74ed835c20636e5f67b22abf3b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga86241e74ed835c20636e5f67b22abf3b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga86241e74ed835c20636e5f67b22abf3b">eblas_zero</a> (int N, T *x)</td></tr>
<tr class="memdesc:ga86241e74ed835c20636e5f67b22abf3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero a data array.  <a href="group__Operators.html#ga86241e74ed835c20636e5f67b22abf3b">More...</a><br /></td></tr>
<tr class="separator:ga86241e74ed835c20636e5f67b22abf3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf6bba434761869bd04fbd191859cc67"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaaf6bba434761869bd04fbd191859cc67">eblas_dscal</a> (int N, double a, double *x, int incx)</td></tr>
<tr class="memdesc:gaaf6bba434761869bd04fbd191859cc67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale a real array: threaded wrapper to the cblas_dscal BLAS1 function. <br /></td></tr>
<tr class="separator:gaaf6bba434761869bd04fbd191859cc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7106ac749d4593f73b27a119e9486e6d"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga7106ac749d4593f73b27a119e9486e6d">eblas_zdscal</a> (int N, double a, <a class="el" href="structcomplex.html">complex</a> *x, int incx)</td></tr>
<tr class="memdesc:ga7106ac749d4593f73b27a119e9486e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale a complex array by a real scale factor: threaded wrapper to the cblas_zdscal BLAS1 function. <br /></td></tr>
<tr class="separator:ga7106ac749d4593f73b27a119e9486e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7511a88828ad90e98f9e7995813b49be"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga7511a88828ad90e98f9e7995813b49be">eblas_zscal</a> (int N, const <a class="el" href="structcomplex.html">complex</a> &amp;a, <a class="el" href="structcomplex.html">complex</a> *x, int incx)</td></tr>
<tr class="memdesc:ga7511a88828ad90e98f9e7995813b49be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale a complex array by a complex scale factor: threaded wrapper to the cblas_zscal BLAS1 function. <br /></td></tr>
<tr class="separator:ga7511a88828ad90e98f9e7995813b49be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad007d0c4eb9fe5c141f9d48bb0dd710"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaad007d0c4eb9fe5c141f9d48bb0dd710">eblas_daxpy</a> (int N, double a, const double *x, int incx, double *y, int incy)</td></tr>
<tr class="memdesc:gaad007d0c4eb9fe5c141f9d48bb0dd710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaled-accumulate on real arrays: threaded wrapper to the cblas_daxpy BLAS1 function. <br /></td></tr>
<tr class="separator:gaad007d0c4eb9fe5c141f9d48bb0dd710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87bedbfedbae0efdb4b4c1207e36783d"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga87bedbfedbae0efdb4b4c1207e36783d">eblas_zaxpy</a> (int N, const <a class="el" href="structcomplex.html">complex</a> &amp;a, const <a class="el" href="structcomplex.html">complex</a> *x, int incx, <a class="el" href="structcomplex.html">complex</a> *y, int incy)</td></tr>
<tr class="memdesc:ga87bedbfedbae0efdb4b4c1207e36783d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaled-accumulate on complex arrays: threaded wrapper to the cblas_zaxpy BLAS1 function. <br /></td></tr>
<tr class="separator:ga87bedbfedbae0efdb4b4c1207e36783d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafafc5a6d2f24e055d3b9d4e36198f706"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="structcomplex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gafafc5a6d2f24e055d3b9d4e36198f706">eblas_zdotc</a> (int N, const <a class="el" href="structcomplex.html">complex</a> *x, int incx, const <a class="el" href="structcomplex.html">complex</a> *y, int incy)</td></tr>
<tr class="memdesc:gafafc5a6d2f24e055d3b9d4e36198f706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product of complex arrays: threaded wrapper to the cblas_zdotc BLAS1 function. <br /></td></tr>
<tr class="separator:gafafc5a6d2f24e055d3b9d4e36198f706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffe4a0ee242ac993d41a38f9914dc583"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaffe4a0ee242ac993d41a38f9914dc583">eblas_ddot</a> (int N, const double *x, int incx, const double *y, int ncy)</td></tr>
<tr class="memdesc:gaffe4a0ee242ac993d41a38f9914dc583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product of real arrays: threaded wrapper to the cblas_ddot BLAS1 function. <br /></td></tr>
<tr class="separator:gaffe4a0ee242ac993d41a38f9914dc583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7605fb2b9744d4e1c7de3439cb87cd99"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga7605fb2b9744d4e1c7de3439cb87cd99">eblas_dznrm2</a> (int N, const <a class="el" href="structcomplex.html">complex</a> *x, int incx)</td></tr>
<tr class="memdesc:ga7605fb2b9744d4e1c7de3439cb87cd99"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-norm of a complex array: threaded wrapper to the cblas_dznrm2 BLAS1 function <br /></td></tr>
<tr class="separator:ga7605fb2b9744d4e1c7de3439cb87cd99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga465cc13a28dd1b92df1929e386516b3e"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga465cc13a28dd1b92df1929e386516b3e">eblas_dnrm2</a> (int N, const double *x, int incx)</td></tr>
<tr class="memdesc:ga465cc13a28dd1b92df1929e386516b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-norm of a real array: threaded wrapper to the cblas_dnrm2 BLAS1 function <br /></td></tr>
<tr class="separator:ga465cc13a28dd1b92df1929e386516b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga702c12a5f0fdc02fa664c20f3fcd4a88"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga702c12a5f0fdc02fa664c20f3fcd4a88"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga702c12a5f0fdc02fa664c20f3fcd4a88">eblas_copy_gpu</a> (T *dest, const T *src, int N)</td></tr>
<tr class="memdesc:ga702c12a5f0fdc02fa664c20f3fcd4a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga3e6f244886dd30b195522884c18637f2" title="Copy a data array.">eblas_copy()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga702c12a5f0fdc02fa664c20f3fcd4a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b16eac198d041a2552414dca8c6f8f1"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1b16eac198d041a2552414dca8c6f8f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga1b16eac198d041a2552414dca8c6f8f1">eblas_zero_gpu</a> (int N, T *x)</td></tr>
<tr class="memdesc:ga1b16eac198d041a2552414dca8c6f8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga86241e74ed835c20636e5f67b22abf3b" title="Zero a data array.">eblas_zero()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga1b16eac198d041a2552414dca8c6f8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb1222170e7c8c52aa42ecb7186d6c9b"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaeb1222170e7c8c52aa42ecb7186d6c9b">eblas_dscal_gpu</a> (int N, double a, double *x, int incx)</td></tr>
<tr class="memdesc:gaeb1222170e7c8c52aa42ecb7186d6c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#gaaf6bba434761869bd04fbd191859cc67" title="Scale a real array: threaded wrapper to the cblas_dscal BLAS1 function.">eblas_dscal()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:gaeb1222170e7c8c52aa42ecb7186d6c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacad8f16e4ac5357add3168d9c49ac2fa"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gacad8f16e4ac5357add3168d9c49ac2fa">eblas_zdscal_gpu</a> (int N, double a, <a class="el" href="structcomplex.html">complex</a> *x, int incx)</td></tr>
<tr class="memdesc:gacad8f16e4ac5357add3168d9c49ac2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga7106ac749d4593f73b27a119e9486e6d" title="Scale a complex array by a real scale factor: threaded wrapper to the cblas_zdscal BLAS1 function.">eblas_zdscal()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:gacad8f16e4ac5357add3168d9c49ac2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f8e8322bf8d0729f1499680e0dfe7cb"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga8f8e8322bf8d0729f1499680e0dfe7cb">eblas_zscal_gpu</a> (int N, const <a class="el" href="structcomplex.html">complex</a> &amp;a, <a class="el" href="structcomplex.html">complex</a> *x, int incx)</td></tr>
<tr class="memdesc:ga8f8e8322bf8d0729f1499680e0dfe7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of eblas_zscal for GPU data pointers. <br /></td></tr>
<tr class="separator:ga8f8e8322bf8d0729f1499680e0dfe7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45171aeb5be499def4741983799d4dd2"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga45171aeb5be499def4741983799d4dd2">eblas_daxpy_gpu</a> (int N, double a, const double *x, int incx, double *y, int incy)</td></tr>
<tr class="memdesc:ga45171aeb5be499def4741983799d4dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#gaad007d0c4eb9fe5c141f9d48bb0dd710" title="Scaled-accumulate on real arrays: threaded wrapper to the cblas_daxpy BLAS1 function.">eblas_daxpy()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga45171aeb5be499def4741983799d4dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf23131853917b31a47d7fbdd512f9a83"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaf23131853917b31a47d7fbdd512f9a83">eblas_zaxpy_gpu</a> (int N, const <a class="el" href="structcomplex.html">complex</a> &amp;a, const <a class="el" href="structcomplex.html">complex</a> *x, int incx, <a class="el" href="structcomplex.html">complex</a> *y, int incy)</td></tr>
<tr class="memdesc:gaf23131853917b31a47d7fbdd512f9a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga87bedbfedbae0efdb4b4c1207e36783d" title="Scaled-accumulate on complex arrays: threaded wrapper to the cblas_zaxpy BLAS1 function.">eblas_zaxpy()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:gaf23131853917b31a47d7fbdd512f9a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga278331b2acb3b0e598b4cc108c8c202e"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="structcomplex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga278331b2acb3b0e598b4cc108c8c202e">eblas_zdotc_gpu</a> (int N, const <a class="el" href="structcomplex.html">complex</a> *x, int incx, const <a class="el" href="structcomplex.html">complex</a> *y, int incy)</td></tr>
<tr class="memdesc:ga278331b2acb3b0e598b4cc108c8c202e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#gafafc5a6d2f24e055d3b9d4e36198f706" title="Dot product of complex arrays: threaded wrapper to the cblas_zdotc BLAS1 function.">eblas_zdotc()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga278331b2acb3b0e598b4cc108c8c202e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50b5f64c58cce77ea36d94644bb82b5a"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga50b5f64c58cce77ea36d94644bb82b5a">eblas_ddot_gpu</a> (int N, const double *x, int incx, const double *y, int incy)</td></tr>
<tr class="memdesc:ga50b5f64c58cce77ea36d94644bb82b5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#gaffe4a0ee242ac993d41a38f9914dc583" title="Dot product of real arrays: threaded wrapper to the cblas_ddot BLAS1 function.">eblas_ddot()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga50b5f64c58cce77ea36d94644bb82b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab71862f9e023ce0f62601f0ea5222b81"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gab71862f9e023ce0f62601f0ea5222b81">eblas_dznrm2_gpu</a> (int N, const <a class="el" href="structcomplex.html">complex</a> *x, int incx)</td></tr>
<tr class="memdesc:gab71862f9e023ce0f62601f0ea5222b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga7605fb2b9744d4e1c7de3439cb87cd99" title="2-norm of a complex array: threaded wrapper to the cblas_dznrm2 BLAS1 function">eblas_dznrm2()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:gab71862f9e023ce0f62601f0ea5222b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d8f869317dbb791f3be9784a019a3ad"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga8d8f869317dbb791f3be9784a019a3ad">eblas_dnrm2_gpu</a> (int N, const double *x, int incx)</td></tr>
<tr class="memdesc:ga8d8f869317dbb791f3be9784a019a3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga465cc13a28dd1b92df1929e386516b3e" title="2-norm of a real array: threaded wrapper to the cblas_dnrm2 BLAS1 function">eblas_dnrm2()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga8d8f869317dbb791f3be9784a019a3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53707938a6bc21c6e01f719a3fe51f30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga53707938a6bc21c6e01f719a3fe51f30">eblas_capMinMax</a> (const int N, double *x, double &amp;xMin, double &amp;xMax, double capLo=-DBL_MAX, double capHi=+DBL_MAX)</td></tr>
<tr class="memdesc:ga53707938a6bc21c6e01f719a3fe51f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the minimum and maximum of a data array and optionally cap it from above and/or below.  <a href="group__Operators.html#ga53707938a6bc21c6e01f719a3fe51f30">More...</a><br /></td></tr>
<tr class="separator:ga53707938a6bc21c6e01f719a3fe51f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae479c614697e16892fe5554f68f3882f"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gae479c614697e16892fe5554f68f3882f">eblas_capMinMax_gpu</a> (const int N, double *x, double &amp;xMin, double &amp;xMax, double capLo=-DBL_MAX, double capHi=+DBL_MAX)</td></tr>
<tr class="memdesc:gae479c614697e16892fe5554f68f3882f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga53707938a6bc21c6e01f719a3fe51f30" title="Find the minimum and maximum of a data array and optionally cap it from above and/or below.">eblas_capMinMax()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:gae479c614697e16892fe5554f68f3882f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af802012e82869f92a0da6af73e970c43"><td class="memItemLeft" align="right" valign="top"><a id="af802012e82869f92a0da6af73e970c43"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DECLARE_eblas_sum</b> (<a class="el" href="group__Operators.html#ga19cd74e6a9a5958b2760ec024c2aa04d">eblas_sum</a>, <a class="el" href="group__Operators.html#gafe47cd65bab7057a60eea6d75b065281">eblas_sumStrided</a>) DECLARE_eblas_sum(<a class="el" href="group__Operators.html#ga47a40a1408d6f741288c098ff5233295">eblas_sum_gpu</a></td></tr>
<tr class="separator:af802012e82869f92a0da6af73e970c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Commonly used BLAS-like routines. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a2de03654a575ed8fd0e64fd362057fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de03654a575ed8fd0e64fd362057fc2">&#9670;&nbsp;</a></span>DECLARE_eblas_sum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DECLARE_eblas_sum</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sumFunc, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sumStridedFunc&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T sumFunc(<span class="keyword">const</span> <span class="keywordtype">int</span> N, <span class="keyword">const</span> T* X) \</div>
<div class="line">        {       <span class="keywordtype">int</span> Ndoubles = <span class="keyword">sizeof</span>(T)/<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>); \</div>
<div class="line">                assert(Ndoubles * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) == <span class="keyword">sizeof</span>(T)); \</div>
<div class="line">                T result; sumStridedFunc(N, Ndoubles, (<span class="keyword">const</span> <span class="keywordtype">double</span>*)X, (<span class="keywordtype">double</span>*)&amp;result); \</div>
<div class="line">                return result; \</div>
<div class="line">        }</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
    <li class="navelem"><a class="el" href="dir_1c6bb07fbe9bf97d79509acc0dbdc376.html">core</a></li><li class="navelem"><a class="el" href="BlasExtra_8h.html">BlasExtra.h</a></li>
</div>
</body>
</html>
