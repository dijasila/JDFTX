<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JDFTx: Operator implementations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="jdftx-55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">JDFTx
   &#160;<span id="projectnumber">1.7.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__Operators.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Operator implementations<div class="ingroups"><a class="el" href="group__Core.html">Core functionality</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:BlasExtra_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html">BlasExtra.h</a></td></tr>
<tr class="memdesc:BlasExtra_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commonly used BLAS-like routines. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:Operators_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Operators_8h.html">Operators.h</a></td></tr>
<tr class="memdesc:Operators_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9" title="A smart reference-counting pointer to ScalarFieldData.">ScalarField</a>'s and <a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547" title="A smart reference-counting pointer to ScalarFieldTildeData.">ScalarFieldTilde</a>'s. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:TranslationOperator_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TranslationOperator_8h.html">TranslationOperator.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classColumnBundleTransform.html">ColumnBundleTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle transformation of ColumnBundles upon symmetry operations.  <a href="classColumnBundleTransform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslationOperator.html">TranslationOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for translation operators.  <a href="classTranslationOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslationOperatorSpline.html">TranslationOperatorSpline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translation operator which works in real space using interpolating splines.  <a href="classTranslationOperatorSpline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslationOperatorFourier.html">TranslationOperatorFourier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exact translation operator in PW basis, although much slower and with potential ringing issues.  <a href="classTranslationOperatorFourier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga60f1cf2483a1cf0031f237bb3e50c299"><td class="memItemLeft" align="right" valign="top"><a id="ga60f1cf2483a1cf0031f237bb3e50c299"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga60f1cf2483a1cf0031f237bb3e50c299">callPref</a>(functionName)&#160;&#160;&#160;functionName##_gpu</td></tr>
<tr class="memdesc:ga60f1cf2483a1cf0031f237bb3e50c299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select between functionName and functionName_gpu for the CPU and GPU executables respectively. <br /></td></tr>
<tr class="separator:ga60f1cf2483a1cf0031f237bb3e50c299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fdb293649df38d6a56b2404df9249a5"><td class="memItemLeft" align="right" valign="top"><a id="ga2fdb293649df38d6a56b2404df9249a5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a>&#160;&#160;&#160;std::shared_ptr&lt;T&gt;</td></tr>
<tr class="memdesc:ga2fdb293649df38d6a56b2404df9249a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">shorthand for writing the template operators (undef'd at end of header) <br /></td></tr>
<tr class="separator:ga2fdb293649df38d6a56b2404df9249a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga16b2911192a4dd45990e8d3c8749bc3c"><td class="memTemplParams" colspan="2">template&lt;typename Ty , typename Tx &gt; </td></tr>
<tr class="memitem:ga16b2911192a4dd45990e8d3c8749bc3c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga16b2911192a4dd45990e8d3c8749bc3c">eblas_mul</a> (const int N, const Tx *X, const int incX, Ty *Y, const int incY)</td></tr>
<tr class="memdesc:ga16b2911192a4dd45990e8d3c8749bc3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated elementwise multiply Y *= X for arrays X, Y.  <a href="group__Operators.html#ga16b2911192a4dd45990e8d3c8749bc3c">More...</a><br /></td></tr>
<tr class="separator:ga16b2911192a4dd45990e8d3c8749bc3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6379a3d39a315ffa2dcf2c92477741b1"><td class="memItemLeft" align="right" valign="top"><a id="ga6379a3d39a315ffa2dcf2c92477741b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga6379a3d39a315ffa2dcf2c92477741b1">eblas_dmul</a> (const int N, const double *X, const int incX, double *Y, const int incY)</td></tr>
<tr class="memdesc:ga6379a3d39a315ffa2dcf2c92477741b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="group__Operators.html#ga16b2911192a4dd45990e8d3c8749bc3c" title="Templated elementwise multiply Y *= X for arrays X, Y.">eblas_mul()</a> for double[] *= double[]. <br /></td></tr>
<tr class="separator:ga6379a3d39a315ffa2dcf2c92477741b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e0b6dcdf4b62d7e67e7317502673c20"><td class="memItemLeft" align="right" valign="top"><a id="ga6e0b6dcdf4b62d7e67e7317502673c20"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga6e0b6dcdf4b62d7e67e7317502673c20">eblas_zmul</a> (const int N, const <a class="el" href="structcomplex.html">complex</a> *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:ga6e0b6dcdf4b62d7e67e7317502673c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="group__Operators.html#ga16b2911192a4dd45990e8d3c8749bc3c" title="Templated elementwise multiply Y *= X for arrays X, Y.">eblas_mul()</a> for complex[] *= complex[]. <br /></td></tr>
<tr class="separator:ga6e0b6dcdf4b62d7e67e7317502673c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2140c951abf8544320da930a0ebd4548"><td class="memItemLeft" align="right" valign="top"><a id="ga2140c951abf8544320da930a0ebd4548"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga2140c951abf8544320da930a0ebd4548">eblas_zmuld</a> (const int N, const double *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:ga2140c951abf8544320da930a0ebd4548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="group__Operators.html#ga16b2911192a4dd45990e8d3c8749bc3c" title="Templated elementwise multiply Y *= X for arrays X, Y.">eblas_mul()</a> for complex[] *= double[]. <br /></td></tr>
<tr class="separator:ga2140c951abf8544320da930a0ebd4548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee5e834dbcc79293125ffb0aa1b54a5e"><td class="memItemLeft" align="right" valign="top"><a id="gaee5e834dbcc79293125ffb0aa1b54a5e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaee5e834dbcc79293125ffb0aa1b54a5e">eblas_dmul_gpu</a> (const int N, const double *X, const int incX, double *Y, const int incY)</td></tr>
<tr class="memdesc:gaee5e834dbcc79293125ffb0aa1b54a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga6379a3d39a315ffa2dcf2c92477741b1" title="Specialization of eblas_mul() for double[] *= double[].">eblas_dmul()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:gaee5e834dbcc79293125ffb0aa1b54a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ef44b279657aad37389393e3f03ed6d"><td class="memItemLeft" align="right" valign="top"><a id="ga3ef44b279657aad37389393e3f03ed6d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga3ef44b279657aad37389393e3f03ed6d">eblas_zmul_gpu</a> (const int N, const <a class="el" href="structcomplex.html">complex</a> *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:ga3ef44b279657aad37389393e3f03ed6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga6e0b6dcdf4b62d7e67e7317502673c20" title="Specialization of eblas_mul() for complex[] *= complex[].">eblas_zmul()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga3ef44b279657aad37389393e3f03ed6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc467ff9f0a44f8eace7f68d5391ccc8"><td class="memItemLeft" align="right" valign="top"><a id="gabc467ff9f0a44f8eace7f68d5391ccc8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gabc467ff9f0a44f8eace7f68d5391ccc8">eblas_zmuld_gpu</a> (const int N, const double *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:gabc467ff9f0a44f8eace7f68d5391ccc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga2140c951abf8544320da930a0ebd4548" title="Specialization of eblas_mul() for complex[] *= double[].">eblas_zmuld()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:gabc467ff9f0a44f8eace7f68d5391ccc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d7f3fb6cf181094d3969a28f2d661f1"><td class="memTemplParams" colspan="2">template&lt;typename Ty , typename Tx &gt; </td></tr>
<tr class="memitem:ga8d7f3fb6cf181094d3969a28f2d661f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga8d7f3fb6cf181094d3969a28f2d661f1">eblas_div</a> (const int N, const Tx *X, const int incX, Ty *Y, const int incY)</td></tr>
<tr class="memdesc:ga8d7f3fb6cf181094d3969a28f2d661f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated elementwise divide Y /= X for arrays X, Y.  <a href="group__Operators.html#ga8d7f3fb6cf181094d3969a28f2d661f1">More...</a><br /></td></tr>
<tr class="separator:ga8d7f3fb6cf181094d3969a28f2d661f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab632432b443a6e1569bd0d35b2b9d875"><td class="memItemLeft" align="right" valign="top"><a id="gab632432b443a6e1569bd0d35b2b9d875"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gab632432b443a6e1569bd0d35b2b9d875">eblas_ddiv</a> (const int N, const double *X, const int incX, double *Y, const int incY)</td></tr>
<tr class="memdesc:gab632432b443a6e1569bd0d35b2b9d875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="group__Operators.html#ga8d7f3fb6cf181094d3969a28f2d661f1" title="Templated elementwise divide Y /= X for arrays X, Y.">eblas_div()</a> for double[] /= double[]. <br /></td></tr>
<tr class="separator:gab632432b443a6e1569bd0d35b2b9d875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a317f91a1c555cc4e57686a68fce61a"><td class="memItemLeft" align="right" valign="top"><a id="ga5a317f91a1c555cc4e57686a68fce61a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga5a317f91a1c555cc4e57686a68fce61a">eblas_zdiv</a> (const int N, const <a class="el" href="structcomplex.html">complex</a> *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:ga5a317f91a1c555cc4e57686a68fce61a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="group__Operators.html#ga8d7f3fb6cf181094d3969a28f2d661f1" title="Templated elementwise divide Y /= X for arrays X, Y.">eblas_div()</a> for <a class="el" href="structcomplex.html" title="Complex number (need to define our own because we need operators for gpu code as well)">complex</a>[] /= <a class="el" href="structcomplex.html" title="Complex number (need to define our own because we need operators for gpu code as well)">complex</a>[]. <br /></td></tr>
<tr class="separator:ga5a317f91a1c555cc4e57686a68fce61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d1d01b5955a584591c77bf491648d10"><td class="memItemLeft" align="right" valign="top"><a id="ga4d1d01b5955a584591c77bf491648d10"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga4d1d01b5955a584591c77bf491648d10">eblas_zdivd</a> (const int N, const double *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:ga4d1d01b5955a584591c77bf491648d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="group__Operators.html#ga8d7f3fb6cf181094d3969a28f2d661f1" title="Templated elementwise divide Y /= X for arrays X, Y.">eblas_div()</a> for <a class="el" href="structcomplex.html" title="Complex number (need to define our own because we need operators for gpu code as well)">complex</a>[] /= double[]. <br /></td></tr>
<tr class="separator:ga4d1d01b5955a584591c77bf491648d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b56254d2d085b314f397614431d9be8"><td class="memItemLeft" align="right" valign="top"><a id="ga6b56254d2d085b314f397614431d9be8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga6b56254d2d085b314f397614431d9be8">eblas_ddiv_gpu</a> (const int N, const double *X, const int incX, double *Y, const int incY)</td></tr>
<tr class="memdesc:ga6b56254d2d085b314f397614431d9be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#gab632432b443a6e1569bd0d35b2b9d875" title="Specialization of eblas_div() for double[] /= double[].">eblas_ddiv()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga6b56254d2d085b314f397614431d9be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90dc7695ae5fa193758cf1dd1167cef2"><td class="memItemLeft" align="right" valign="top"><a id="ga90dc7695ae5fa193758cf1dd1167cef2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga90dc7695ae5fa193758cf1dd1167cef2">eblas_zdiv_gpu</a> (const int N, const <a class="el" href="structcomplex.html">complex</a> *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:ga90dc7695ae5fa193758cf1dd1167cef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga5a317f91a1c555cc4e57686a68fce61a" title="Specialization of eblas_div() for complex[] /= complex[].">eblas_zdiv()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga90dc7695ae5fa193758cf1dd1167cef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38da349ef7eb56da44c850ce79513abd"><td class="memItemLeft" align="right" valign="top"><a id="ga38da349ef7eb56da44c850ce79513abd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga38da349ef7eb56da44c850ce79513abd">eblas_zdivd_gpu</a> (const int N, const double *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:ga38da349ef7eb56da44c850ce79513abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga4d1d01b5955a584591c77bf491648d10" title="Specialization of eblas_div() for complex[] /= double[].">eblas_zdivd()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga38da349ef7eb56da44c850ce79513abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe47cd65bab7057a60eea6d75b065281"><td class="memItemLeft" align="right" valign="top"><a id="gafe47cd65bab7057a60eea6d75b065281"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gafe47cd65bab7057a60eea6d75b065281">eblas_sumStrided</a> (const int N, const int stride, const double *X, double *result)</td></tr>
<tr class="memdesc:gafe47cd65bab7057a60eea6d75b065281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return sum over array of doubles with specified stride. <br /></td></tr>
<tr class="separator:gafe47cd65bab7057a60eea6d75b065281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81e1949388c17af1f3a06480413c7380"><td class="memItemLeft" align="right" valign="top"><a id="ga81e1949388c17af1f3a06480413c7380"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga81e1949388c17af1f3a06480413c7380">eblas_sumStrided_gpu</a> (const int N, const int stride, const double *X, double *result)</td></tr>
<tr class="memdesc:ga81e1949388c17af1f3a06480413c7380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#gafe47cd65bab7057a60eea6d75b065281" title="Return sum over array of doubles with specified stride.">eblas_sumStrided()</a> for X on GPU; result is on CPU. <br /></td></tr>
<tr class="separator:ga81e1949388c17af1f3a06480413c7380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19cd74e6a9a5958b2760ec024c2aa04d"><td class="memTemplParams" colspan="2"><a id="ga19cd74e6a9a5958b2760ec024c2aa04d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga19cd74e6a9a5958b2760ec024c2aa04d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga19cd74e6a9a5958b2760ec024c2aa04d">eblas_sum</a> (const int N, const T *X)</td></tr>
<tr class="memdesc:ga19cd74e6a9a5958b2760ec024c2aa04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return sum over array of generic type T composed only of a certain number of double members. <br /></td></tr>
<tr class="separator:ga19cd74e6a9a5958b2760ec024c2aa04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47a40a1408d6f741288c098ff5233295"><td class="memTemplParams" colspan="2"><a id="ga47a40a1408d6f741288c098ff5233295"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga47a40a1408d6f741288c098ff5233295"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga47a40a1408d6f741288c098ff5233295">eblas_sum_gpu</a> (const int N, const T *X)</td></tr>
<tr class="memdesc:ga47a40a1408d6f741288c098ff5233295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga19cd74e6a9a5958b2760ec024c2aa04d" title="Return sum over array of generic type T composed only of a certain number of double members.">eblas_sum()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga47a40a1408d6f741288c098ff5233295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77f427ab61421ff49e1a5e3f2e4bd5ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga77f427ab61421ff49e1a5e3f2e4bd5ab">eblas_lincomb</a> (const int N, const <a class="el" href="structcomplex.html">complex</a> &amp;sX, const <a class="el" href="structcomplex.html">complex</a> *X, const int incX, const <a class="el" href="structcomplex.html">complex</a> &amp;sY, const <a class="el" href="structcomplex.html">complex</a> *Y, const int incY, <a class="el" href="structcomplex.html">complex</a> *Z, const int incZ)</td></tr>
<tr class="memdesc:ga77f427ab61421ff49e1a5e3f2e4bd5ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise linear combination Z = sX * X + sY * Y.  <a href="group__Operators.html#ga77f427ab61421ff49e1a5e3f2e4bd5ab">More...</a><br /></td></tr>
<tr class="separator:ga77f427ab61421ff49e1a5e3f2e4bd5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d58c4fae414cd9011e7f50d8943b6fc"><td class="memItemLeft" align="right" valign="top"><a id="ga8d58c4fae414cd9011e7f50d8943b6fc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga8d58c4fae414cd9011e7f50d8943b6fc">eblas_lincomb_gpu</a> (const int N, const <a class="el" href="structcomplex.html">complex</a> &amp;sX, const <a class="el" href="structcomplex.html">complex</a> *X, const int incX, const <a class="el" href="structcomplex.html">complex</a> &amp;sY, const <a class="el" href="structcomplex.html">complex</a> *Y, const int incY, <a class="el" href="structcomplex.html">complex</a> *Z, const int incZ)</td></tr>
<tr class="memdesc:ga8d58c4fae414cd9011e7f50d8943b6fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga77f427ab61421ff49e1a5e3f2e4bd5ab" title="Elementwise linear combination Z = sX * X + sY * Y.">eblas_lincomb()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga8d58c4fae414cd9011e7f50d8943b6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bd2a68d44d54ff9cc6547fcd15baf8a"><td class="memItemLeft" align="right" valign="top"><a id="ga2bd2a68d44d54ff9cc6547fcd15baf8a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga2bd2a68d44d54ff9cc6547fcd15baf8a">eblas_zgemm</a> (CBLAS_TRANSPOSE TransA, CBLAS_TRANSPOSE TransB, int M, int N, int K, const <a class="el" href="structcomplex.html">complex</a> &amp;alpha, const <a class="el" href="structcomplex.html">complex</a> *A, const int lda, const <a class="el" href="structcomplex.html">complex</a> *B, const int ldb, const <a class="el" href="structcomplex.html">complex</a> &amp;beta, <a class="el" href="structcomplex.html">complex</a> *C, const int ldc)</td></tr>
<tr class="memdesc:ga2bd2a68d44d54ff9cc6547fcd15baf8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threaded complex matrix multiply (threaded wrapper around zgemm) All the parameters have the same meaning as in cblas_zgemm, except element order is always Column Major (FORTRAN order!) <br /></td></tr>
<tr class="separator:ga2bd2a68d44d54ff9cc6547fcd15baf8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0586fe5f4eadb75205bad2eeaecd224c"><td class="memItemLeft" align="right" valign="top"><a id="ga0586fe5f4eadb75205bad2eeaecd224c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga0586fe5f4eadb75205bad2eeaecd224c">eblas_zgemm_gpu</a> (CBLAS_TRANSPOSE TransA, CBLAS_TRANSPOSE TransB, int M, int N, int K, const <a class="el" href="structcomplex.html">complex</a> &amp;alpha, const <a class="el" href="structcomplex.html">complex</a> *A, const int lda, const <a class="el" href="structcomplex.html">complex</a> *B, const int ldb, const <a class="el" href="structcomplex.html">complex</a> &amp;beta, <a class="el" href="structcomplex.html">complex</a> *C, const int ldc)</td></tr>
<tr class="memdesc:ga0586fe5f4eadb75205bad2eeaecd224c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap cublasZgemm to provide the same interface as <a class="el" href="group__Operators.html#ga2bd2a68d44d54ff9cc6547fcd15baf8a" title="Threaded complex matrix multiply (threaded wrapper around zgemm) All the parameters have the same mea...">eblas_zgemm()</a> <br /></td></tr>
<tr class="separator:ga0586fe5f4eadb75205bad2eeaecd224c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6920f2c3375ac67c6baf1af5c8043063"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga6920f2c3375ac67c6baf1af5c8043063">eblas_scatter_zdaxpy</a> (const int Nindex, double a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjx=false, const <a class="el" href="structcomplex.html">complex</a> *w=0, bool conjw=false)</td></tr>
<tr class="memdesc:ga6920f2c3375ac67c6baf1af5c8043063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter y(index) += a * x.  <a href="group__Operators.html#ga6920f2c3375ac67c6baf1af5c8043063">More...</a><br /></td></tr>
<tr class="separator:ga6920f2c3375ac67c6baf1af5c8043063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8401f2eef0fc7b6b7aa22066a82bf3c1"><td class="memItemLeft" align="right" valign="top"><a id="ga8401f2eef0fc7b6b7aa22066a82bf3c1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga8401f2eef0fc7b6b7aa22066a82bf3c1">eblas_scatter_zaxpy</a> (const int Nindex, <a class="el" href="structcomplex.html">complex</a> a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjx=false, const <a class="el" href="structcomplex.html">complex</a> *w=0, bool conjw=false)</td></tr>
<tr class="memdesc:ga8401f2eef0fc7b6b7aa22066a82bf3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga6920f2c3375ac67c6baf1af5c8043063" title="Scatter y(index) += a * x.">eblas_scatter_zdaxpy()</a> with a complex scale factor. <br /></td></tr>
<tr class="separator:ga8401f2eef0fc7b6b7aa22066a82bf3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2ba4babf1d2cbf1ab787c8c33c5ee91"><td class="memItemLeft" align="right" valign="top"><a id="gad2ba4babf1d2cbf1ab787c8c33c5ee91"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gad2ba4babf1d2cbf1ab787c8c33c5ee91">eblas_scatter_daxpy</a> (const int Nindex, double a, const int *index, const double *x, double *y, const double *w=0)</td></tr>
<tr class="memdesc:gad2ba4babf1d2cbf1ab787c8c33c5ee91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga6920f2c3375ac67c6baf1af5c8043063" title="Scatter y(index) += a * x.">eblas_scatter_zdaxpy()</a> for real data arrays. <br /></td></tr>
<tr class="separator:gad2ba4babf1d2cbf1ab787c8c33c5ee91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga749e567418ffb3a1c3b9de6774eeb493"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga749e567418ffb3a1c3b9de6774eeb493">eblas_gather_zdaxpy</a> (const int Nindex, double a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjx=false, const <a class="el" href="structcomplex.html">complex</a> *w=0, bool conjw=false)</td></tr>
<tr class="memdesc:ga749e567418ffb3a1c3b9de6774eeb493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather y += a * x(index)  <a href="group__Operators.html#ga749e567418ffb3a1c3b9de6774eeb493">More...</a><br /></td></tr>
<tr class="separator:ga749e567418ffb3a1c3b9de6774eeb493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a97b86d5b2ab21d4d1fb918f13f3cc9"><td class="memItemLeft" align="right" valign="top"><a id="ga2a97b86d5b2ab21d4d1fb918f13f3cc9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga2a97b86d5b2ab21d4d1fb918f13f3cc9">eblas_gather_zaxpy</a> (const int Nindex, <a class="el" href="structcomplex.html">complex</a> a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjx=false, const <a class="el" href="structcomplex.html">complex</a> *w=0, bool conjw=false)</td></tr>
<tr class="memdesc:ga2a97b86d5b2ab21d4d1fb918f13f3cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga749e567418ffb3a1c3b9de6774eeb493" title="Gather y += a * x(index)">eblas_gather_zdaxpy()</a> with a complex scale factor. <br /></td></tr>
<tr class="separator:ga2a97b86d5b2ab21d4d1fb918f13f3cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cbc123f1c40b70689d154c73817736a"><td class="memItemLeft" align="right" valign="top"><a id="ga3cbc123f1c40b70689d154c73817736a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga3cbc123f1c40b70689d154c73817736a">eblas_gather_daxpy</a> (const int Nindex, double a, const int *index, const double *x, double *y, const double *w=0)</td></tr>
<tr class="memdesc:ga3cbc123f1c40b70689d154c73817736a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga6920f2c3375ac67c6baf1af5c8043063" title="Scatter y(index) += a * x.">eblas_scatter_zdaxpy()</a> for real data arrays. <br /></td></tr>
<tr class="separator:ga3cbc123f1c40b70689d154c73817736a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dd3623c1986cc3347b38d084d9a9e71"><td class="memItemLeft" align="right" valign="top"><a id="ga3dd3623c1986cc3347b38d084d9a9e71"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga3dd3623c1986cc3347b38d084d9a9e71">eblas_scatter_zdaxpy_gpu</a> (const int Nindex, double a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjx=false, const <a class="el" href="structcomplex.html">complex</a> *w=0, bool conjw=false)</td></tr>
<tr class="memdesc:ga3dd3623c1986cc3347b38d084d9a9e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga6920f2c3375ac67c6baf1af5c8043063" title="Scatter y(index) += a * x.">eblas_scatter_zdaxpy()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga3dd3623c1986cc3347b38d084d9a9e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab777fea35e9b776432add8df3f2ff2f7"><td class="memItemLeft" align="right" valign="top"><a id="gab777fea35e9b776432add8df3f2ff2f7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gab777fea35e9b776432add8df3f2ff2f7">eblas_scatter_zaxpy_gpu</a> (const int Nindex, <a class="el" href="structcomplex.html">complex</a> a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjx=false, const <a class="el" href="structcomplex.html">complex</a> *w=0, bool conjw=false)</td></tr>
<tr class="memdesc:gab777fea35e9b776432add8df3f2ff2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga8401f2eef0fc7b6b7aa22066a82bf3c1" title="Equivalent of eblas_scatter_zdaxpy() with a complex scale factor.">eblas_scatter_zaxpy()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:gab777fea35e9b776432add8df3f2ff2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13b559e3aa3e1a00e892f19102140cbd"><td class="memItemLeft" align="right" valign="top"><a id="ga13b559e3aa3e1a00e892f19102140cbd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga13b559e3aa3e1a00e892f19102140cbd">eblas_scatter_daxpy_gpu</a> (const int Nindex, double a, const int *index, const double *x, double *y, const double *w=0)</td></tr>
<tr class="memdesc:ga13b559e3aa3e1a00e892f19102140cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#gad2ba4babf1d2cbf1ab787c8c33c5ee91" title="Equivalent of eblas_scatter_zdaxpy() for real data arrays.">eblas_scatter_daxpy()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga13b559e3aa3e1a00e892f19102140cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bcee46d09c50792e323bd2e6024d3a5"><td class="memItemLeft" align="right" valign="top"><a id="ga5bcee46d09c50792e323bd2e6024d3a5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga5bcee46d09c50792e323bd2e6024d3a5">eblas_gather_zdaxpy_gpu</a> (const int Nindex, double a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjx=false, const <a class="el" href="structcomplex.html">complex</a> *w=0, bool conjw=false)</td></tr>
<tr class="memdesc:ga5bcee46d09c50792e323bd2e6024d3a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga749e567418ffb3a1c3b9de6774eeb493" title="Gather y += a * x(index)">eblas_gather_zdaxpy()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga5bcee46d09c50792e323bd2e6024d3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga577e87716bb8bb527693f6a7832f2d7f"><td class="memItemLeft" align="right" valign="top"><a id="ga577e87716bb8bb527693f6a7832f2d7f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga577e87716bb8bb527693f6a7832f2d7f">eblas_gather_zaxpy_gpu</a> (const int Nindex, <a class="el" href="structcomplex.html">complex</a> a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjx=false, const <a class="el" href="structcomplex.html">complex</a> *w=0, bool conjw=false)</td></tr>
<tr class="memdesc:ga577e87716bb8bb527693f6a7832f2d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga2a97b86d5b2ab21d4d1fb918f13f3cc9" title="Equivalent of eblas_gather_zdaxpy() with a complex scale factor.">eblas_gather_zaxpy()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga577e87716bb8bb527693f6a7832f2d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e81fcb0406e3cac6c632fe90f4740ac"><td class="memItemLeft" align="right" valign="top"><a id="ga4e81fcb0406e3cac6c632fe90f4740ac"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga4e81fcb0406e3cac6c632fe90f4740ac">eblas_gather_daxpy_gpu</a> (const int Nindex, double a, const int *index, const double *x, double *y, const double *w=0)</td></tr>
<tr class="memdesc:ga4e81fcb0406e3cac6c632fe90f4740ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga3cbc123f1c40b70689d154c73817736a" title="Equivalent of eblas_scatter_zdaxpy() for real data arrays.">eblas_gather_daxpy()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga4e81fcb0406e3cac6c632fe90f4740ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c1b03241b133beaed04728d26a086e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga6c1b03241b133beaed04728d26a086e3">eblas_accumNorm</a> (int N, const double &amp;a, const <a class="el" href="structcomplex.html">complex</a> *x, double *y)</td></tr>
<tr class="memdesc:ga6c1b03241b133beaed04728d26a086e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate elementwise norm of a complex array x into y i.e. y += a x conj(x)  <a href="group__Operators.html#ga6c1b03241b133beaed04728d26a086e3">More...</a><br /></td></tr>
<tr class="separator:ga6c1b03241b133beaed04728d26a086e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e140105e5e7ee1f8baaff4e6a016bf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga1e140105e5e7ee1f8baaff4e6a016bf5">eblas_accumProd</a> (int N, const double &amp;a, const <a class="el" href="structcomplex.html">complex</a> *xU, const <a class="el" href="structcomplex.html">complex</a> *xC, double *yRe, double *yIm)</td></tr>
<tr class="memdesc:ga1e140105e5e7ee1f8baaff4e6a016bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate elementwise product of two complex arrays xU and xC into real and imaginary parts yRe and yIm i.e. (yRe + i yIm) += a xU conj(xC)  <a href="group__Operators.html#ga1e140105e5e7ee1f8baaff4e6a016bf5">More...</a><br /></td></tr>
<tr class="separator:ga1e140105e5e7ee1f8baaff4e6a016bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf54b09ce097bfea9cfa343e2040c9bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gacf54b09ce097bfea9cfa343e2040c9bd">eblas_accumProdComplex</a> (int N, const double &amp;a, const <a class="el" href="structcomplex.html">complex</a> *xU, const <a class="el" href="structcomplex.html">complex</a> *xC, <a class="el" href="structcomplex.html">complex</a> *y)</td></tr>
<tr class="memdesc:gacf54b09ce097bfea9cfa343e2040c9bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate elementwise product of two complex arrays xU and xC into y.  <a href="group__Operators.html#gacf54b09ce097bfea9cfa343e2040c9bd">More...</a><br /></td></tr>
<tr class="separator:gacf54b09ce097bfea9cfa343e2040c9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4990759337c29d9752c444b78e3930db"><td class="memItemLeft" align="right" valign="top"><a id="ga4990759337c29d9752c444b78e3930db"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga4990759337c29d9752c444b78e3930db">eblas_accumNorm_gpu</a> (int N, const double &amp;a, const <a class="el" href="structcomplex.html">complex</a> *x, double *y)</td></tr>
<tr class="memdesc:ga4990759337c29d9752c444b78e3930db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga6c1b03241b133beaed04728d26a086e3" title="Accumulate elementwise norm of a complex array x into y i.e. y += a x conj(x)">eblas_accumNorm()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga4990759337c29d9752c444b78e3930db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25e99d5e1c919ea332e5232c4ddf7258"><td class="memItemLeft" align="right" valign="top"><a id="ga25e99d5e1c919ea332e5232c4ddf7258"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga25e99d5e1c919ea332e5232c4ddf7258">eblas_accumProd_gpu</a> (int N, const double &amp;a, const <a class="el" href="structcomplex.html">complex</a> *xU, const <a class="el" href="structcomplex.html">complex</a> *xC, double *yRe, double *yIm)</td></tr>
<tr class="memdesc:ga25e99d5e1c919ea332e5232c4ddf7258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga1e140105e5e7ee1f8baaff4e6a016bf5" title="Accumulate elementwise product of two complex arrays xU and xC into real and imaginary parts yRe and ...">eblas_accumProd()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga25e99d5e1c919ea332e5232c4ddf7258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga551a0d0d63dda5c0df121deeb6183d0f"><td class="memItemLeft" align="right" valign="top"><a id="ga551a0d0d63dda5c0df121deeb6183d0f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga551a0d0d63dda5c0df121deeb6183d0f">eblas_accumProdComplex_gpu</a> (int N, const double &amp;a, const <a class="el" href="structcomplex.html">complex</a> *xU, const <a class="el" href="structcomplex.html">complex</a> *xC, <a class="el" href="structcomplex.html">complex</a> *y)</td></tr>
<tr class="memdesc:ga551a0d0d63dda5c0df121deeb6183d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga1e140105e5e7ee1f8baaff4e6a016bf5" title="Accumulate elementwise product of two complex arrays xU and xC into real and imaginary parts yRe and ...">eblas_accumProd()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga551a0d0d63dda5c0df121deeb6183d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d2cefdcc0e49ab0781fab0609ef5d74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga9d2cefdcc0e49ab0781fab0609ef5d74">eblas_symmetrize</a> (int N, int n, const int *symmIndex, double *x)</td></tr>
<tr class="memdesc:ga9d2cefdcc0e49ab0781fab0609ef5d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symmetrize an array x, using N n-fold equivalence classes in symmIndex.  <a href="group__Operators.html#ga9d2cefdcc0e49ab0781fab0609ef5d74">More...</a><br /></td></tr>
<tr class="separator:ga9d2cefdcc0e49ab0781fab0609ef5d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0c011b9e8e8f8086690068bcfa7ca92"><td class="memItemLeft" align="right" valign="top"><a id="gaa0c011b9e8e8f8086690068bcfa7ca92"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaa0c011b9e8e8f8086690068bcfa7ca92">eblas_symmetrize</a> (int N, int n, const int *symmIndex, <a class="el" href="structcomplex.html">complex</a> *x)</td></tr>
<tr class="memdesc:gaa0c011b9e8e8f8086690068bcfa7ca92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga9d2cefdcc0e49ab0781fab0609ef5d74" title="Symmetrize an array x, using N n-fold equivalence classes in symmIndex.">eblas_symmetrize()</a> for complex data pointers. <br /></td></tr>
<tr class="separator:gaa0c011b9e8e8f8086690068bcfa7ca92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae81ee89ce9455db6d3a33ed7d85dea5"><td class="memItemLeft" align="right" valign="top"><a id="gaae81ee89ce9455db6d3a33ed7d85dea5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaae81ee89ce9455db6d3a33ed7d85dea5">eblas_symmetrize_gpu</a> (int N, int n, const int *symmIndex, double *x)</td></tr>
<tr class="memdesc:gaae81ee89ce9455db6d3a33ed7d85dea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga9d2cefdcc0e49ab0781fab0609ef5d74" title="Symmetrize an array x, using N n-fold equivalence classes in symmIndex.">eblas_symmetrize()</a> for real GPU data pointers. <br /></td></tr>
<tr class="separator:gaae81ee89ce9455db6d3a33ed7d85dea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a72763dcf3012ff1978f77c9f569ce8"><td class="memItemLeft" align="right" valign="top"><a id="ga5a72763dcf3012ff1978f77c9f569ce8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga5a72763dcf3012ff1978f77c9f569ce8">eblas_symmetrize_gpu</a> (int N, int n, const int *symmIndex, <a class="el" href="structcomplex.html">complex</a> *x)</td></tr>
<tr class="memdesc:ga5a72763dcf3012ff1978f77c9f569ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga9d2cefdcc0e49ab0781fab0609ef5d74" title="Symmetrize an array x, using N n-fold equivalence classes in symmIndex.">eblas_symmetrize()</a> for complex GPU data pointers. <br /></td></tr>
<tr class="separator:ga5a72763dcf3012ff1978f77c9f569ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae73590ae7d8bc5430e35a0eca6590b09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gae73590ae7d8bc5430e35a0eca6590b09">eblas_symmetrize</a> (int N, int n, const int *symmIndex, const int *symmMult, const <a class="el" href="structcomplex.html">complex</a> *phase, <a class="el" href="structcomplex.html">complex</a> *x)</td></tr>
<tr class="memdesc:gae73590ae7d8bc5430e35a0eca6590b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symmetrize a complex array x with phase factors, using N n-fold equivalence classes in symmIndex (useful for space group symmetrization in reciprocal space)  <a href="group__Operators.html#gae73590ae7d8bc5430e35a0eca6590b09">More...</a><br /></td></tr>
<tr class="separator:gae73590ae7d8bc5430e35a0eca6590b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a426fdd52157c7d1a984f5d2c4876c8"><td class="memItemLeft" align="right" valign="top"><a id="ga8a426fdd52157c7d1a984f5d2c4876c8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga8a426fdd52157c7d1a984f5d2c4876c8">eblas_symmetrize_gpu</a> (int N, int n, const int *symmIndex, const int *symmMult, const <a class="el" href="structcomplex.html">complex</a> *phase, <a class="el" href="structcomplex.html">complex</a> *x)</td></tr>
<tr class="memdesc:ga8a426fdd52157c7d1a984f5d2c4876c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga9d2cefdcc0e49ab0781fab0609ef5d74" title="Symmetrize an array x, using N n-fold equivalence classes in symmIndex.">eblas_symmetrize()</a> for complex GPU data pointers. <br /></td></tr>
<tr class="separator:ga8a426fdd52157c7d1a984f5d2c4876c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a00682eceae2e0e80fd1d3a3fea409b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga1a00682eceae2e0e80fd1d3a3fea409b">eblas_symmetrize</a> (int N, int n, const int *symmIndex, const int *symmMult, const <a class="el" href="structcomplex.html">complex</a> *phase, const <a class="el" href="classmatrix3.html">matrix3</a>&lt;&gt; *rotSpin, std::vector&lt; <a class="el" href="structcomplex.html">complex</a> * &gt; x)</td></tr>
<tr class="memdesc:ga1a00682eceae2e0e80fd1d3a3fea409b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symmetrize a quadruplet of complex arrays with phase factors, using N n-fold equivalence classes in symmIndex (useful for space group symmetrization of spin density matrices in reciprocal space)  <a href="group__Operators.html#ga1a00682eceae2e0e80fd1d3a3fea409b">More...</a><br /></td></tr>
<tr class="separator:ga1a00682eceae2e0e80fd1d3a3fea409b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2eb5564b322ca31807d8322f4baec415"><td class="memItemLeft" align="right" valign="top"><a id="ga2eb5564b322ca31807d8322f4baec415"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga2eb5564b322ca31807d8322f4baec415">eblas_symmetrize_gpu</a> (int N, int n, const int *symmIndex, const int *symmMult, const <a class="el" href="structcomplex.html">complex</a> *phase, const <a class="el" href="classmatrix3.html">matrix3</a>&lt;&gt; *rotSpin, std::vector&lt; <a class="el" href="structcomplex.html">complex</a> * &gt; x)</td></tr>
<tr class="memdesc:ga2eb5564b322ca31807d8322f4baec415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga9d2cefdcc0e49ab0781fab0609ef5d74" title="Symmetrize an array x, using N n-fold equivalence classes in symmIndex.">eblas_symmetrize()</a> for complex GPU data pointers. <br /></td></tr>
<tr class="separator:ga2eb5564b322ca31807d8322f4baec415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e6f244886dd30b195522884c18637f2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3e6f244886dd30b195522884c18637f2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga3e6f244886dd30b195522884c18637f2">eblas_copy</a> (T *dest, const T *src, int N)</td></tr>
<tr class="memdesc:ga3e6f244886dd30b195522884c18637f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a data array.  <a href="group__Operators.html#ga3e6f244886dd30b195522884c18637f2">More...</a><br /></td></tr>
<tr class="separator:ga3e6f244886dd30b195522884c18637f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86241e74ed835c20636e5f67b22abf3b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga86241e74ed835c20636e5f67b22abf3b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga86241e74ed835c20636e5f67b22abf3b">eblas_zero</a> (int N, T *x)</td></tr>
<tr class="memdesc:ga86241e74ed835c20636e5f67b22abf3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero a data array.  <a href="group__Operators.html#ga86241e74ed835c20636e5f67b22abf3b">More...</a><br /></td></tr>
<tr class="separator:ga86241e74ed835c20636e5f67b22abf3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf6bba434761869bd04fbd191859cc67"><td class="memItemLeft" align="right" valign="top"><a id="gaaf6bba434761869bd04fbd191859cc67"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaaf6bba434761869bd04fbd191859cc67">eblas_dscal</a> (int N, double a, double *x, int incx)</td></tr>
<tr class="memdesc:gaaf6bba434761869bd04fbd191859cc67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale a real array: threaded wrapper to the cblas_dscal BLAS1 function. <br /></td></tr>
<tr class="separator:gaaf6bba434761869bd04fbd191859cc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7106ac749d4593f73b27a119e9486e6d"><td class="memItemLeft" align="right" valign="top"><a id="ga7106ac749d4593f73b27a119e9486e6d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga7106ac749d4593f73b27a119e9486e6d">eblas_zdscal</a> (int N, double a, <a class="el" href="structcomplex.html">complex</a> *x, int incx)</td></tr>
<tr class="memdesc:ga7106ac749d4593f73b27a119e9486e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale a complex array by a real scale factor: threaded wrapper to the cblas_zdscal BLAS1 function. <br /></td></tr>
<tr class="separator:ga7106ac749d4593f73b27a119e9486e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7511a88828ad90e98f9e7995813b49be"><td class="memItemLeft" align="right" valign="top"><a id="ga7511a88828ad90e98f9e7995813b49be"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga7511a88828ad90e98f9e7995813b49be">eblas_zscal</a> (int N, const <a class="el" href="structcomplex.html">complex</a> &amp;a, <a class="el" href="structcomplex.html">complex</a> *x, int incx)</td></tr>
<tr class="memdesc:ga7511a88828ad90e98f9e7995813b49be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale a complex array by a complex scale factor: threaded wrapper to the cblas_zscal BLAS1 function. <br /></td></tr>
<tr class="separator:ga7511a88828ad90e98f9e7995813b49be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad007d0c4eb9fe5c141f9d48bb0dd710"><td class="memItemLeft" align="right" valign="top"><a id="gaad007d0c4eb9fe5c141f9d48bb0dd710"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaad007d0c4eb9fe5c141f9d48bb0dd710">eblas_daxpy</a> (int N, double a, const double *x, int incx, double *y, int incy)</td></tr>
<tr class="memdesc:gaad007d0c4eb9fe5c141f9d48bb0dd710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaled-accumulate on real arrays: threaded wrapper to the cblas_daxpy BLAS1 function. <br /></td></tr>
<tr class="separator:gaad007d0c4eb9fe5c141f9d48bb0dd710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87bedbfedbae0efdb4b4c1207e36783d"><td class="memItemLeft" align="right" valign="top"><a id="ga87bedbfedbae0efdb4b4c1207e36783d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga87bedbfedbae0efdb4b4c1207e36783d">eblas_zaxpy</a> (int N, const <a class="el" href="structcomplex.html">complex</a> &amp;a, const <a class="el" href="structcomplex.html">complex</a> *x, int incx, <a class="el" href="structcomplex.html">complex</a> *y, int incy)</td></tr>
<tr class="memdesc:ga87bedbfedbae0efdb4b4c1207e36783d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaled-accumulate on complex arrays: threaded wrapper to the cblas_zaxpy BLAS1 function. <br /></td></tr>
<tr class="separator:ga87bedbfedbae0efdb4b4c1207e36783d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafafc5a6d2f24e055d3b9d4e36198f706"><td class="memItemLeft" align="right" valign="top"><a id="gafafc5a6d2f24e055d3b9d4e36198f706"></a>
<a class="el" href="structcomplex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gafafc5a6d2f24e055d3b9d4e36198f706">eblas_zdotc</a> (int N, const <a class="el" href="structcomplex.html">complex</a> *x, int incx, const <a class="el" href="structcomplex.html">complex</a> *y, int incy)</td></tr>
<tr class="memdesc:gafafc5a6d2f24e055d3b9d4e36198f706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product of complex arrays: threaded wrapper to the cblas_zdotc BLAS1 function. <br /></td></tr>
<tr class="separator:gafafc5a6d2f24e055d3b9d4e36198f706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffe4a0ee242ac993d41a38f9914dc583"><td class="memItemLeft" align="right" valign="top"><a id="gaffe4a0ee242ac993d41a38f9914dc583"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaffe4a0ee242ac993d41a38f9914dc583">eblas_ddot</a> (int N, const double *x, int incx, const double *y, int ncy)</td></tr>
<tr class="memdesc:gaffe4a0ee242ac993d41a38f9914dc583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product of real arrays: threaded wrapper to the cblas_ddot BLAS1 function. <br /></td></tr>
<tr class="separator:gaffe4a0ee242ac993d41a38f9914dc583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7605fb2b9744d4e1c7de3439cb87cd99"><td class="memItemLeft" align="right" valign="top"><a id="ga7605fb2b9744d4e1c7de3439cb87cd99"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga7605fb2b9744d4e1c7de3439cb87cd99">eblas_dznrm2</a> (int N, const <a class="el" href="structcomplex.html">complex</a> *x, int incx)</td></tr>
<tr class="memdesc:ga7605fb2b9744d4e1c7de3439cb87cd99"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-norm of a complex array: threaded wrapper to the cblas_dznrm2 BLAS1 function <br /></td></tr>
<tr class="separator:ga7605fb2b9744d4e1c7de3439cb87cd99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga465cc13a28dd1b92df1929e386516b3e"><td class="memItemLeft" align="right" valign="top"><a id="ga465cc13a28dd1b92df1929e386516b3e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga465cc13a28dd1b92df1929e386516b3e">eblas_dnrm2</a> (int N, const double *x, int incx)</td></tr>
<tr class="memdesc:ga465cc13a28dd1b92df1929e386516b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-norm of a real array: threaded wrapper to the cblas_dnrm2 BLAS1 function <br /></td></tr>
<tr class="separator:ga465cc13a28dd1b92df1929e386516b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga702c12a5f0fdc02fa664c20f3fcd4a88"><td class="memTemplParams" colspan="2"><a id="ga702c12a5f0fdc02fa664c20f3fcd4a88"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga702c12a5f0fdc02fa664c20f3fcd4a88"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga702c12a5f0fdc02fa664c20f3fcd4a88">eblas_copy_gpu</a> (T *dest, const T *src, int N)</td></tr>
<tr class="memdesc:ga702c12a5f0fdc02fa664c20f3fcd4a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga3e6f244886dd30b195522884c18637f2" title="Copy a data array.">eblas_copy()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga702c12a5f0fdc02fa664c20f3fcd4a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b16eac198d041a2552414dca8c6f8f1"><td class="memTemplParams" colspan="2"><a id="ga1b16eac198d041a2552414dca8c6f8f1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1b16eac198d041a2552414dca8c6f8f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga1b16eac198d041a2552414dca8c6f8f1">eblas_zero_gpu</a> (int N, T *x)</td></tr>
<tr class="memdesc:ga1b16eac198d041a2552414dca8c6f8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga86241e74ed835c20636e5f67b22abf3b" title="Zero a data array.">eblas_zero()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga1b16eac198d041a2552414dca8c6f8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb1222170e7c8c52aa42ecb7186d6c9b"><td class="memItemLeft" align="right" valign="top"><a id="gaeb1222170e7c8c52aa42ecb7186d6c9b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaeb1222170e7c8c52aa42ecb7186d6c9b">eblas_dscal_gpu</a> (int N, double a, double *x, int incx)</td></tr>
<tr class="memdesc:gaeb1222170e7c8c52aa42ecb7186d6c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#gaaf6bba434761869bd04fbd191859cc67" title="Scale a real array: threaded wrapper to the cblas_dscal BLAS1 function.">eblas_dscal()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:gaeb1222170e7c8c52aa42ecb7186d6c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacad8f16e4ac5357add3168d9c49ac2fa"><td class="memItemLeft" align="right" valign="top"><a id="gacad8f16e4ac5357add3168d9c49ac2fa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gacad8f16e4ac5357add3168d9c49ac2fa">eblas_zdscal_gpu</a> (int N, double a, <a class="el" href="structcomplex.html">complex</a> *x, int incx)</td></tr>
<tr class="memdesc:gacad8f16e4ac5357add3168d9c49ac2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga7106ac749d4593f73b27a119e9486e6d" title="Scale a complex array by a real scale factor: threaded wrapper to the cblas_zdscal BLAS1 function.">eblas_zdscal()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:gacad8f16e4ac5357add3168d9c49ac2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f8e8322bf8d0729f1499680e0dfe7cb"><td class="memItemLeft" align="right" valign="top"><a id="ga8f8e8322bf8d0729f1499680e0dfe7cb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga8f8e8322bf8d0729f1499680e0dfe7cb">eblas_zscal_gpu</a> (int N, const <a class="el" href="structcomplex.html">complex</a> &amp;a, <a class="el" href="structcomplex.html">complex</a> *x, int incx)</td></tr>
<tr class="memdesc:ga8f8e8322bf8d0729f1499680e0dfe7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of eblas_zscal for GPU data pointers. <br /></td></tr>
<tr class="separator:ga8f8e8322bf8d0729f1499680e0dfe7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45171aeb5be499def4741983799d4dd2"><td class="memItemLeft" align="right" valign="top"><a id="ga45171aeb5be499def4741983799d4dd2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga45171aeb5be499def4741983799d4dd2">eblas_daxpy_gpu</a> (int N, double a, const double *x, int incx, double *y, int incy)</td></tr>
<tr class="memdesc:ga45171aeb5be499def4741983799d4dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#gaad007d0c4eb9fe5c141f9d48bb0dd710" title="Scaled-accumulate on real arrays: threaded wrapper to the cblas_daxpy BLAS1 function.">eblas_daxpy()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga45171aeb5be499def4741983799d4dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf23131853917b31a47d7fbdd512f9a83"><td class="memItemLeft" align="right" valign="top"><a id="gaf23131853917b31a47d7fbdd512f9a83"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaf23131853917b31a47d7fbdd512f9a83">eblas_zaxpy_gpu</a> (int N, const <a class="el" href="structcomplex.html">complex</a> &amp;a, const <a class="el" href="structcomplex.html">complex</a> *x, int incx, <a class="el" href="structcomplex.html">complex</a> *y, int incy)</td></tr>
<tr class="memdesc:gaf23131853917b31a47d7fbdd512f9a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga87bedbfedbae0efdb4b4c1207e36783d" title="Scaled-accumulate on complex arrays: threaded wrapper to the cblas_zaxpy BLAS1 function.">eblas_zaxpy()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:gaf23131853917b31a47d7fbdd512f9a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga278331b2acb3b0e598b4cc108c8c202e"><td class="memItemLeft" align="right" valign="top"><a id="ga278331b2acb3b0e598b4cc108c8c202e"></a>
<a class="el" href="structcomplex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga278331b2acb3b0e598b4cc108c8c202e">eblas_zdotc_gpu</a> (int N, const <a class="el" href="structcomplex.html">complex</a> *x, int incx, const <a class="el" href="structcomplex.html">complex</a> *y, int incy)</td></tr>
<tr class="memdesc:ga278331b2acb3b0e598b4cc108c8c202e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#gafafc5a6d2f24e055d3b9d4e36198f706" title="Dot product of complex arrays: threaded wrapper to the cblas_zdotc BLAS1 function.">eblas_zdotc()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga278331b2acb3b0e598b4cc108c8c202e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50b5f64c58cce77ea36d94644bb82b5a"><td class="memItemLeft" align="right" valign="top"><a id="ga50b5f64c58cce77ea36d94644bb82b5a"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga50b5f64c58cce77ea36d94644bb82b5a">eblas_ddot_gpu</a> (int N, const double *x, int incx, const double *y, int incy)</td></tr>
<tr class="memdesc:ga50b5f64c58cce77ea36d94644bb82b5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#gaffe4a0ee242ac993d41a38f9914dc583" title="Dot product of real arrays: threaded wrapper to the cblas_ddot BLAS1 function.">eblas_ddot()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga50b5f64c58cce77ea36d94644bb82b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab71862f9e023ce0f62601f0ea5222b81"><td class="memItemLeft" align="right" valign="top"><a id="gab71862f9e023ce0f62601f0ea5222b81"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gab71862f9e023ce0f62601f0ea5222b81">eblas_dznrm2_gpu</a> (int N, const <a class="el" href="structcomplex.html">complex</a> *x, int incx)</td></tr>
<tr class="memdesc:gab71862f9e023ce0f62601f0ea5222b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga7605fb2b9744d4e1c7de3439cb87cd99" title="2-norm of a complex array: threaded wrapper to the cblas_dznrm2 BLAS1 function">eblas_dznrm2()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:gab71862f9e023ce0f62601f0ea5222b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d8f869317dbb791f3be9784a019a3ad"><td class="memItemLeft" align="right" valign="top"><a id="ga8d8f869317dbb791f3be9784a019a3ad"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga8d8f869317dbb791f3be9784a019a3ad">eblas_dnrm2_gpu</a> (int N, const double *x, int incx)</td></tr>
<tr class="memdesc:ga8d8f869317dbb791f3be9784a019a3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga465cc13a28dd1b92df1929e386516b3e" title="2-norm of a real array: threaded wrapper to the cblas_dnrm2 BLAS1 function">eblas_dnrm2()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ga8d8f869317dbb791f3be9784a019a3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53707938a6bc21c6e01f719a3fe51f30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga53707938a6bc21c6e01f719a3fe51f30">eblas_capMinMax</a> (const int N, double *x, double &amp;xMin, double &amp;xMax, double capLo=-DBL_MAX, double capHi=+DBL_MAX)</td></tr>
<tr class="memdesc:ga53707938a6bc21c6e01f719a3fe51f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the minimum and maximum of a data array and optionally cap it from above and/or below.  <a href="group__Operators.html#ga53707938a6bc21c6e01f719a3fe51f30">More...</a><br /></td></tr>
<tr class="separator:ga53707938a6bc21c6e01f719a3fe51f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae479c614697e16892fe5554f68f3882f"><td class="memItemLeft" align="right" valign="top"><a id="gae479c614697e16892fe5554f68f3882f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gae479c614697e16892fe5554f68f3882f">eblas_capMinMax_gpu</a> (const int N, double *x, double &amp;xMin, double &amp;xMax, double capLo=-DBL_MAX, double capHi=+DBL_MAX)</td></tr>
<tr class="memdesc:gae479c614697e16892fe5554f68f3882f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga53707938a6bc21c6e01f719a3fe51f30" title="Find the minimum and maximum of a data array and optionally cap it from above and/or below.">eblas_capMinMax()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:gae479c614697e16892fe5554f68f3882f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71338497668fd7c941ef5ceb95f117f5"><td class="memItemLeft" align="right" valign="top"><a id="ga71338497668fd7c941ef5ceb95f117f5"></a>
<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga71338497668fd7c941ef5ceb95f117f5">Real</a> (const <a class="el" href="group__DataStructures.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a> &amp;)</td></tr>
<tr class="memdesc:ga71338497668fd7c941ef5ceb95f117f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">real part of a complex scalar field (real-space) <br /></td></tr>
<tr class="separator:ga71338497668fd7c941ef5ceb95f117f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf85997f29a53ce518ac99de34317074"><td class="memItemLeft" align="right" valign="top"><a id="gabf85997f29a53ce518ac99de34317074"></a>
<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gabf85997f29a53ce518ac99de34317074">Real</a> (const <a class="el" href="group__DataStructures.html#gac243b4be10d9bc0b4e5b3c3339bbaf10">complexScalarFieldTilde</a> &amp;)</td></tr>
<tr class="memdesc:gabf85997f29a53ce518ac99de34317074"><td class="mdescLeft">&#160;</td><td class="mdescRight">real part of a complex scalar field (reciprocal space) <br /></td></tr>
<tr class="separator:gabf85997f29a53ce518ac99de34317074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba9419a703fb66911a0fb81b14b64e48"><td class="memItemLeft" align="right" valign="top"><a id="gaba9419a703fb66911a0fb81b14b64e48"></a>
<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaba9419a703fb66911a0fb81b14b64e48">Imag</a> (const <a class="el" href="group__DataStructures.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a> &amp;)</td></tr>
<tr class="memdesc:gaba9419a703fb66911a0fb81b14b64e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">imaginary part of a complex scalar field (real-space) <br /></td></tr>
<tr class="separator:gaba9419a703fb66911a0fb81b14b64e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a46622d8879eb88401a4a7506303dc9"><td class="memItemLeft" align="right" valign="top"><a id="ga4a46622d8879eb88401a4a7506303dc9"></a>
<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga4a46622d8879eb88401a4a7506303dc9">Imag</a> (const <a class="el" href="group__DataStructures.html#gac243b4be10d9bc0b4e5b3c3339bbaf10">complexScalarFieldTilde</a> &amp;)</td></tr>
<tr class="memdesc:ga4a46622d8879eb88401a4a7506303dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">imaginary part of a complex scalar field (reciprocal space) <br /></td></tr>
<tr class="separator:ga4a46622d8879eb88401a4a7506303dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8262dcec1a394931fac35ce27f9a65c2"><td class="memItemLeft" align="right" valign="top"><a id="ga8262dcec1a394931fac35ce27f9a65c2"></a>
<a class="el" href="group__DataStructures.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga8262dcec1a394931fac35ce27f9a65c2">Complex</a> (const <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;)</td></tr>
<tr class="memdesc:ga8262dcec1a394931fac35ce27f9a65c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert real to complex scalar field with zero imaginary part (real-space) <br /></td></tr>
<tr class="separator:ga8262dcec1a394931fac35ce27f9a65c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga648ff70ef0ed0fd2e0bd83dd1315c6fb"><td class="memItemLeft" align="right" valign="top"><a id="ga648ff70ef0ed0fd2e0bd83dd1315c6fb"></a>
<a class="el" href="group__DataStructures.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga648ff70ef0ed0fd2e0bd83dd1315c6fb">Complex</a> (const <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;re, const <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;im)</td></tr>
<tr class="memdesc:ga648ff70ef0ed0fd2e0bd83dd1315c6fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct complex scalar field fromr eal and imaginary parts (real-space) <br /></td></tr>
<tr class="separator:ga648ff70ef0ed0fd2e0bd83dd1315c6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeba8d4962b0c4763cbfc3cb199f0ecb"><td class="memItemLeft" align="right" valign="top"><a id="gaeeba8d4962b0c4763cbfc3cb199f0ecb"></a>
<a class="el" href="group__DataStructures.html#gac243b4be10d9bc0b4e5b3c3339bbaf10">complexScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaeeba8d4962b0c4763cbfc3cb199f0ecb">Complex</a> (const <a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;)</td></tr>
<tr class="memdesc:gaeeba8d4962b0c4763cbfc3cb199f0ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert real to complex scalar field with zero imaginary part (reciprocal-space) <br /></td></tr>
<tr class="separator:gaeeba8d4962b0c4763cbfc3cb199f0ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf095663007df51c911b6434cd33ecfbd"><td class="memItemLeft" align="right" valign="top"><a id="gaf095663007df51c911b6434cd33ecfbd"></a>
<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaf095663007df51c911b6434cd33ecfbd">O</a> (const <a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;)</td></tr>
<tr class="memdesc:gaf095663007df51c911b6434cd33ecfbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inner product operator (diagonal in PW basis) <br /></td></tr>
<tr class="separator:gaf095663007df51c911b6434cd33ecfbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab56743c56f4c4e8f4786945ed1bc395"><td class="memItemLeft" align="right" valign="top"><a id="gaab56743c56f4c4e8f4786945ed1bc395"></a>
<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaab56743c56f4c4e8f4786945ed1bc395">O</a> (<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;&amp;)</td></tr>
<tr class="memdesc:gaab56743c56f4c4e8f4786945ed1bc395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inner product operator (diagonal in PW basis) <br /></td></tr>
<tr class="separator:gaab56743c56f4c4e8f4786945ed1bc395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga632c569ea6f426065b2e41824e7bab6c"><td class="memItemLeft" align="right" valign="top"><a id="ga632c569ea6f426065b2e41824e7bab6c"></a>
<a class="el" href="group__DataStructures.html#gac243b4be10d9bc0b4e5b3c3339bbaf10">complexScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga632c569ea6f426065b2e41824e7bab6c">O</a> (const <a class="el" href="group__DataStructures.html#gac243b4be10d9bc0b4e5b3c3339bbaf10">complexScalarFieldTilde</a> &amp;)</td></tr>
<tr class="memdesc:ga632c569ea6f426065b2e41824e7bab6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inner product operator (diagonal in PW basis) <br /></td></tr>
<tr class="separator:ga632c569ea6f426065b2e41824e7bab6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62654d46c082c3dc317852044a0345cd"><td class="memItemLeft" align="right" valign="top"><a id="ga62654d46c082c3dc317852044a0345cd"></a>
<a class="el" href="group__DataStructures.html#gac243b4be10d9bc0b4e5b3c3339bbaf10">complexScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga62654d46c082c3dc317852044a0345cd">O</a> (<a class="el" href="group__DataStructures.html#gac243b4be10d9bc0b4e5b3c3339bbaf10">complexScalarFieldTilde</a> &amp;&amp;)</td></tr>
<tr class="memdesc:ga62654d46c082c3dc317852044a0345cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inner product operator (diagonal in PW basis) <br /></td></tr>
<tr class="separator:ga62654d46c082c3dc317852044a0345cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadba30eb2d786a923b553c6dd7d85071e"><td class="memItemLeft" align="right" valign="top"><a id="gadba30eb2d786a923b553c6dd7d85071e"></a>
<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gadba30eb2d786a923b553c6dd7d85071e">I</a> (const <a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;, int nThreads=0)</td></tr>
<tr class="memdesc:gadba30eb2d786a923b553c6dd7d85071e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward transform: PW basis -&gt; real space (preserve input) <br /></td></tr>
<tr class="separator:gadba30eb2d786a923b553c6dd7d85071e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b807a8e1528b1925a46b137046ec9b9"><td class="memItemLeft" align="right" valign="top"><a id="ga0b807a8e1528b1925a46b137046ec9b9"></a>
<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga0b807a8e1528b1925a46b137046ec9b9">I</a> (<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;&amp;, int nThreads=0)</td></tr>
<tr class="memdesc:ga0b807a8e1528b1925a46b137046ec9b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward transform: PW basis -&gt; real space (destructible input) <br /></td></tr>
<tr class="separator:ga0b807a8e1528b1925a46b137046ec9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf26e8989d81c71beab6df838fec9345e"><td class="memItemLeft" align="right" valign="top"><a id="gaf26e8989d81c71beab6df838fec9345e"></a>
<a class="el" href="group__DataStructures.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaf26e8989d81c71beab6df838fec9345e">I</a> (const <a class="el" href="group__DataStructures.html#gac243b4be10d9bc0b4e5b3c3339bbaf10">complexScalarFieldTilde</a> &amp;, int nThreads=0)</td></tr>
<tr class="memdesc:gaf26e8989d81c71beab6df838fec9345e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward transform: PW basis -&gt; real space (preserve input) <br /></td></tr>
<tr class="separator:gaf26e8989d81c71beab6df838fec9345e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae76f2c1d0f449a164c435bb06b294674"><td class="memItemLeft" align="right" valign="top"><a id="gae76f2c1d0f449a164c435bb06b294674"></a>
<a class="el" href="group__DataStructures.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gae76f2c1d0f449a164c435bb06b294674">I</a> (<a class="el" href="group__DataStructures.html#gac243b4be10d9bc0b4e5b3c3339bbaf10">complexScalarFieldTilde</a> &amp;&amp;, int nThreads=0)</td></tr>
<tr class="memdesc:gae76f2c1d0f449a164c435bb06b294674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward transform: PW basis -&gt; real space (destructible input) <br /></td></tr>
<tr class="separator:gae76f2c1d0f449a164c435bb06b294674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f892807028472f587093e64949d13fb"><td class="memItemLeft" align="right" valign="top"><a id="ga5f892807028472f587093e64949d13fb"></a>
<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga5f892807028472f587093e64949d13fb">J</a> (const <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;, int nThreads=0)</td></tr>
<tr class="memdesc:ga5f892807028472f587093e64949d13fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse transform: Real space -&gt; PW basis. <br /></td></tr>
<tr class="separator:ga5f892807028472f587093e64949d13fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61270ca5ba8a9a12b056cc17682d424a"><td class="memItemLeft" align="right" valign="top"><a id="ga61270ca5ba8a9a12b056cc17682d424a"></a>
<a class="el" href="group__DataStructures.html#gac243b4be10d9bc0b4e5b3c3339bbaf10">complexScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga61270ca5ba8a9a12b056cc17682d424a">J</a> (const <a class="el" href="group__DataStructures.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a> &amp;, int nThreads=0)</td></tr>
<tr class="memdesc:ga61270ca5ba8a9a12b056cc17682d424a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse transform: Real space -&gt; PW basis (preserve input) <br /></td></tr>
<tr class="separator:ga61270ca5ba8a9a12b056cc17682d424a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30fa7f56e8d5d0ce41a3dc800a5bc3cf"><td class="memItemLeft" align="right" valign="top"><a id="ga30fa7f56e8d5d0ce41a3dc800a5bc3cf"></a>
<a class="el" href="group__DataStructures.html#gac243b4be10d9bc0b4e5b3c3339bbaf10">complexScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga30fa7f56e8d5d0ce41a3dc800a5bc3cf">J</a> (<a class="el" href="group__DataStructures.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a> &amp;&amp;, int nThreads=0)</td></tr>
<tr class="memdesc:ga30fa7f56e8d5d0ce41a3dc800a5bc3cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse transform: Real space -&gt; PW basis (destructible input) <br /></td></tr>
<tr class="separator:ga30fa7f56e8d5d0ce41a3dc800a5bc3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a76afb3aa7e184d20c96bf82fc8b892"><td class="memItemLeft" align="right" valign="top"><a id="ga5a76afb3aa7e184d20c96bf82fc8b892"></a>
<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga5a76afb3aa7e184d20c96bf82fc8b892">Idag</a> (const <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;, int nThreads=0)</td></tr>
<tr class="memdesc:ga5a76afb3aa7e184d20c96bf82fc8b892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward transform transpose: Real space -&gt; PW basis. <br /></td></tr>
<tr class="separator:ga5a76afb3aa7e184d20c96bf82fc8b892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga592e15383fb3a870a099bd01f62e07c8"><td class="memItemLeft" align="right" valign="top"><a id="ga592e15383fb3a870a099bd01f62e07c8"></a>
<a class="el" href="group__DataStructures.html#gac243b4be10d9bc0b4e5b3c3339bbaf10">complexScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga592e15383fb3a870a099bd01f62e07c8">Idag</a> (const <a class="el" href="group__DataStructures.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a> &amp;, int nThreads=0)</td></tr>
<tr class="memdesc:ga592e15383fb3a870a099bd01f62e07c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward transform transpose: Real space -&gt; PW basis (preserve input) <br /></td></tr>
<tr class="separator:ga592e15383fb3a870a099bd01f62e07c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4061cd6ef0de766fdb79270db83aee91"><td class="memItemLeft" align="right" valign="top"><a id="ga4061cd6ef0de766fdb79270db83aee91"></a>
<a class="el" href="group__DataStructures.html#gac243b4be10d9bc0b4e5b3c3339bbaf10">complexScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga4061cd6ef0de766fdb79270db83aee91">Idag</a> (<a class="el" href="group__DataStructures.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a> &amp;&amp;, int nThreads=0)</td></tr>
<tr class="memdesc:ga4061cd6ef0de766fdb79270db83aee91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward transform transpose: Real space -&gt; PW basis (destructible input) <br /></td></tr>
<tr class="separator:ga4061cd6ef0de766fdb79270db83aee91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab19bff17f3bb7a2432e0ddff8bb5b969"><td class="memItemLeft" align="right" valign="top"><a id="gab19bff17f3bb7a2432e0ddff8bb5b969"></a>
<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gab19bff17f3bb7a2432e0ddff8bb5b969">Jdag</a> (const <a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;, int nThreads=0)</td></tr>
<tr class="memdesc:gab19bff17f3bb7a2432e0ddff8bb5b969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse transform transpose: PW basis -&gt; real space (preserve input) <br /></td></tr>
<tr class="separator:gab19bff17f3bb7a2432e0ddff8bb5b969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5797d8cbc92a3a8cbd100e7939039ce4"><td class="memItemLeft" align="right" valign="top"><a id="ga5797d8cbc92a3a8cbd100e7939039ce4"></a>
<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga5797d8cbc92a3a8cbd100e7939039ce4">Jdag</a> (<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;&amp;, int nThreads=0)</td></tr>
<tr class="memdesc:ga5797d8cbc92a3a8cbd100e7939039ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse transform transpose: PW basis -&gt; real space (destructible input) <br /></td></tr>
<tr class="separator:ga5797d8cbc92a3a8cbd100e7939039ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga264f13c7ec47f3530faf6a330cb6e0fa"><td class="memItemLeft" align="right" valign="top"><a id="ga264f13c7ec47f3530faf6a330cb6e0fa"></a>
<a class="el" href="group__DataStructures.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga264f13c7ec47f3530faf6a330cb6e0fa">Jdag</a> (const <a class="el" href="group__DataStructures.html#gac243b4be10d9bc0b4e5b3c3339bbaf10">complexScalarFieldTilde</a> &amp;, int nThreads=0)</td></tr>
<tr class="memdesc:ga264f13c7ec47f3530faf6a330cb6e0fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse transform transpose: PW basis -&gt; real space (preserve input) <br /></td></tr>
<tr class="separator:ga264f13c7ec47f3530faf6a330cb6e0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga729feb984631d1418254d05c665c31f4"><td class="memItemLeft" align="right" valign="top"><a id="ga729feb984631d1418254d05c665c31f4"></a>
<a class="el" href="group__DataStructures.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga729feb984631d1418254d05c665c31f4">Jdag</a> (<a class="el" href="group__DataStructures.html#gac243b4be10d9bc0b4e5b3c3339bbaf10">complexScalarFieldTilde</a> &amp;&amp;, int nThreads=0)</td></tr>
<tr class="memdesc:ga729feb984631d1418254d05c665c31f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse transform transpose: PW basis -&gt; real space (destructible input) <br /></td></tr>
<tr class="separator:ga729feb984631d1418254d05c665c31f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41b3a35a57bb16a75716c5e17a0ad12b"><td class="memItemLeft" align="right" valign="top"><a id="ga41b3a35a57bb16a75716c5e17a0ad12b"></a>
<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga41b3a35a57bb16a75716c5e17a0ad12b">JdagOJ</a> (const <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;)</td></tr>
<tr class="memdesc:ga41b3a35a57bb16a75716c5e17a0ad12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate Jdag(O(J())), which avoids 2 fourier transforms in PW basis (preserve input) <br /></td></tr>
<tr class="separator:ga41b3a35a57bb16a75716c5e17a0ad12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5be65f9f1dc5293a21fc8fcf13baa656"><td class="memItemLeft" align="right" valign="top"><a id="ga5be65f9f1dc5293a21fc8fcf13baa656"></a>
<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga5be65f9f1dc5293a21fc8fcf13baa656">JdagOJ</a> (<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;&amp;)</td></tr>
<tr class="memdesc:ga5be65f9f1dc5293a21fc8fcf13baa656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate Jdag(O(J())), which avoids 2 fourier transforms in PW basis (destructible input) <br /></td></tr>
<tr class="separator:ga5be65f9f1dc5293a21fc8fcf13baa656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33e8f1b37a3c8af921e0e04a1ca3db7f"><td class="memItemLeft" align="right" valign="top"><a id="ga33e8f1b37a3c8af921e0e04a1ca3db7f"></a>
<a class="el" href="group__DataStructures.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga33e8f1b37a3c8af921e0e04a1ca3db7f">JdagOJ</a> (const <a class="el" href="group__DataStructures.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a> &amp;)</td></tr>
<tr class="memdesc:ga33e8f1b37a3c8af921e0e04a1ca3db7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate Jdag(O(J())), which avoids 2 fourier transforms in PW basis (preserve input) <br /></td></tr>
<tr class="separator:ga33e8f1b37a3c8af921e0e04a1ca3db7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9db386f5353df6a08e8174cf37ed059a"><td class="memItemLeft" align="right" valign="top"><a id="ga9db386f5353df6a08e8174cf37ed059a"></a>
<a class="el" href="group__DataStructures.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga9db386f5353df6a08e8174cf37ed059a">JdagOJ</a> (<a class="el" href="group__DataStructures.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a> &amp;&amp;)</td></tr>
<tr class="memdesc:ga9db386f5353df6a08e8174cf37ed059a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate Jdag(O(J())), which avoids 2 fourier transforms in PW basis (destructible input) <br /></td></tr>
<tr class="separator:ga9db386f5353df6a08e8174cf37ed059a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ec23a133a869027aabe0ff69416098c"><td class="memItemLeft" align="right" valign="top"><a id="ga3ec23a133a869027aabe0ff69416098c"></a>
<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga3ec23a133a869027aabe0ff69416098c">L</a> (const <a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;)</td></tr>
<tr class="memdesc:ga3ec23a133a869027aabe0ff69416098c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Laplacian. <br /></td></tr>
<tr class="separator:ga3ec23a133a869027aabe0ff69416098c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57cdbf674f659ec92117c2723fbe1041"><td class="memItemLeft" align="right" valign="top"><a id="ga57cdbf674f659ec92117c2723fbe1041"></a>
<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga57cdbf674f659ec92117c2723fbe1041">L</a> (<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;&amp;)</td></tr>
<tr class="memdesc:ga57cdbf674f659ec92117c2723fbe1041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Laplacian. <br /></td></tr>
<tr class="separator:ga57cdbf674f659ec92117c2723fbe1041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32f2044bbbf883442ef1bef985a8a161"><td class="memItemLeft" align="right" valign="top"><a id="ga32f2044bbbf883442ef1bef985a8a161"></a>
<a class="el" href="group__DataStructures.html#gac243b4be10d9bc0b4e5b3c3339bbaf10">complexScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga32f2044bbbf883442ef1bef985a8a161">L</a> (const <a class="el" href="group__DataStructures.html#gac243b4be10d9bc0b4e5b3c3339bbaf10">complexScalarFieldTilde</a> &amp;)</td></tr>
<tr class="memdesc:ga32f2044bbbf883442ef1bef985a8a161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Laplacian. <br /></td></tr>
<tr class="separator:ga32f2044bbbf883442ef1bef985a8a161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeff4b1799cf81f1461948b41f8540c33"><td class="memItemLeft" align="right" valign="top"><a id="gaeff4b1799cf81f1461948b41f8540c33"></a>
<a class="el" href="group__DataStructures.html#gac243b4be10d9bc0b4e5b3c3339bbaf10">complexScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaeff4b1799cf81f1461948b41f8540c33">L</a> (<a class="el" href="group__DataStructures.html#gac243b4be10d9bc0b4e5b3c3339bbaf10">complexScalarFieldTilde</a> &amp;&amp;)</td></tr>
<tr class="memdesc:gaeff4b1799cf81f1461948b41f8540c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Laplacian. <br /></td></tr>
<tr class="separator:gaeff4b1799cf81f1461948b41f8540c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7d77ea83beeab9d54d3449486206533"><td class="memItemLeft" align="right" valign="top"><a id="gad7d77ea83beeab9d54d3449486206533"></a>
<a class="el" href="classmatrix3.html">matrix3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gad7d77ea83beeab9d54d3449486206533">Lstress</a> (const <a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;X, const <a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;Y)</td></tr>
<tr class="memdesc:gad7d77ea83beeab9d54d3449486206533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lattice vector derivative of dot(X,L(Y)) <br /></td></tr>
<tr class="separator:gad7d77ea83beeab9d54d3449486206533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38b5711e00e7f670eec824ed0b6cb513"><td class="memItemLeft" align="right" valign="top"><a id="ga38b5711e00e7f670eec824ed0b6cb513"></a>
<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga38b5711e00e7f670eec824ed0b6cb513">Linv</a> (const <a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;)</td></tr>
<tr class="memdesc:ga38b5711e00e7f670eec824ed0b6cb513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse Laplacian. <br /></td></tr>
<tr class="separator:ga38b5711e00e7f670eec824ed0b6cb513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9488747d1840ff8960979b54f897cd29"><td class="memItemLeft" align="right" valign="top"><a id="ga9488747d1840ff8960979b54f897cd29"></a>
<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga9488747d1840ff8960979b54f897cd29">Linv</a> (<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;&amp;)</td></tr>
<tr class="memdesc:ga9488747d1840ff8960979b54f897cd29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse Laplacian. <br /></td></tr>
<tr class="separator:ga9488747d1840ff8960979b54f897cd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70dc326dd7129ab6c5f05ace5baa9689"><td class="memItemLeft" align="right" valign="top"><a id="ga70dc326dd7129ab6c5f05ace5baa9689"></a>
<a class="el" href="group__DataStructures.html#gac243b4be10d9bc0b4e5b3c3339bbaf10">complexScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga70dc326dd7129ab6c5f05ace5baa9689">Linv</a> (const <a class="el" href="group__DataStructures.html#gac243b4be10d9bc0b4e5b3c3339bbaf10">complexScalarFieldTilde</a> &amp;, <a class="el" href="classvector3.html">vector3</a>&lt;&gt; *k=0)</td></tr>
<tr class="memdesc:ga70dc326dd7129ab6c5f05ace5baa9689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse Laplacian. <br /></td></tr>
<tr class="separator:ga70dc326dd7129ab6c5f05ace5baa9689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga279987c9e7cbc2580dc9bfdb7c4c293b"><td class="memItemLeft" align="right" valign="top"><a id="ga279987c9e7cbc2580dc9bfdb7c4c293b"></a>
<a class="el" href="group__DataStructures.html#gac243b4be10d9bc0b4e5b3c3339bbaf10">complexScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga279987c9e7cbc2580dc9bfdb7c4c293b">Linv</a> (<a class="el" href="group__DataStructures.html#gac243b4be10d9bc0b4e5b3c3339bbaf10">complexScalarFieldTilde</a> &amp;&amp;, <a class="el" href="classvector3.html">vector3</a>&lt;&gt; *k=0)</td></tr>
<tr class="memdesc:ga279987c9e7cbc2580dc9bfdb7c4c293b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse Laplacian. <br /></td></tr>
<tr class="separator:ga279987c9e7cbc2580dc9bfdb7c4c293b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac46089fa20df71450929ec85fb08f554"><td class="memItemLeft" align="right" valign="top"><a id="gac46089fa20df71450929ec85fb08f554"></a>
<a class="el" href="group__DataStructures.html#gac243b4be10d9bc0b4e5b3c3339bbaf10">complexScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Linv</b> (const <a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;in, <a class="el" href="classvector3.html">vector3</a>&lt;&gt; *k)</td></tr>
<tr class="separator:gac46089fa20df71450929ec85fb08f554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga595ed6b4aaa38ce3fac1abe87a2a1af0"><td class="memItemLeft" align="right" valign="top"><a id="ga595ed6b4aaa38ce3fac1abe87a2a1af0"></a>
<a class="el" href="classmatrix3.html">matrix3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga595ed6b4aaa38ce3fac1abe87a2a1af0">LinvStress</a> (const <a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;X, const <a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;Y)</td></tr>
<tr class="memdesc:ga595ed6b4aaa38ce3fac1abe87a2a1af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lattice vector derivative of dot(X,Linv(Y)) <br /></td></tr>
<tr class="separator:ga595ed6b4aaa38ce3fac1abe87a2a1af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92cb5c0efe834a7b4739215a370ae060"><td class="memItemLeft" align="right" valign="top"><a id="ga92cb5c0efe834a7b4739215a370ae060"></a>
<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga92cb5c0efe834a7b4739215a370ae060">D</a> (const <a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;, int iDir)</td></tr>
<tr class="memdesc:ga92cb5c0efe834a7b4739215a370ae060"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the gradient in the iDir'th cartesian direction <br /></td></tr>
<tr class="separator:ga92cb5c0efe834a7b4739215a370ae060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade0f8a6f5fe59d0c541bf049b7a04b7b"><td class="memItemLeft" align="right" valign="top"><a id="gade0f8a6f5fe59d0c541bf049b7a04b7b"></a>
<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gade0f8a6f5fe59d0c541bf049b7a04b7b">D</a> (const <a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;in, const <a class="el" href="classvector3.html">vector3</a>&lt;&gt; &amp;dir)</td></tr>
<tr class="memdesc:gade0f8a6f5fe59d0c541bf049b7a04b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">directional derivative of scalar field along (cartesian direction) dir <br /></td></tr>
<tr class="separator:gade0f8a6f5fe59d0c541bf049b7a04b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09d276a3c8ef8d18156c549d42258b25"><td class="memItemLeft" align="right" valign="top"><a id="ga09d276a3c8ef8d18156c549d42258b25"></a>
<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga09d276a3c8ef8d18156c549d42258b25">DD</a> (const <a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;, int iDir, int jDir)</td></tr>
<tr class="memdesc:ga09d276a3c8ef8d18156c549d42258b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">second derivative along iDir'th and jDir'th cartesian directions <br /></td></tr>
<tr class="separator:ga09d276a3c8ef8d18156c549d42258b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cf62cee67f85b96628a54993f91aedb"><td class="memItemLeft" align="right" valign="top"><a id="ga1cf62cee67f85b96628a54993f91aedb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga1cf62cee67f85b96628a54993f91aedb">zeroNyquist</a> (<a class="el" href="structRealKernel.html">RealKernel</a> &amp;Gdata)</td></tr>
<tr class="memdesc:ga1cf62cee67f85b96628a54993f91aedb"><td class="mdescLeft">&#160;</td><td class="mdescRight">zeros out all the nyquist components of a real G-kernel <br /></td></tr>
<tr class="separator:ga1cf62cee67f85b96628a54993f91aedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20f87098ba6d3652d0db2b121c36b6ce"><td class="memItemLeft" align="right" valign="top"><a id="ga20f87098ba6d3652d0db2b121c36b6ce"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga20f87098ba6d3652d0db2b121c36b6ce">zeroNyquist</a> (<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;Gptr)</td></tr>
<tr class="memdesc:ga20f87098ba6d3652d0db2b121c36b6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">zeros out all the nyquist components of a G-space data array <br /></td></tr>
<tr class="separator:ga20f87098ba6d3652d0db2b121c36b6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8219bcd6cb0dd08b59b22c5838a2e0a"><td class="memItemLeft" align="right" valign="top"><a id="gaf8219bcd6cb0dd08b59b22c5838a2e0a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaf8219bcd6cb0dd08b59b22c5838a2e0a">zeroNyquist</a> (<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;Rptr)</td></tr>
<tr class="memdesc:gaf8219bcd6cb0dd08b59b22c5838a2e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">zeros out all the nyquist components of an R-space data array <br /></td></tr>
<tr class="separator:gaf8219bcd6cb0dd08b59b22c5838a2e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3b8ee5929a836d73ccf24bb582c46ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gab3b8ee5929a836d73ccf24bb582c46ef">removePhase</a> (size_t N, <a class="el" href="structcomplex.html">complex</a> *data, double &amp;meanPhase, double &amp;sigmaPhase, double &amp;rmsImagErr)</td></tr>
<tr class="separator:gab3b8ee5929a836d73ccf24bb582c46ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadde3201543eec30a27334541262e8513"><td class="memItemLeft" align="right" valign="top"><a id="gadde3201543eec30a27334541262e8513"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gadde3201543eec30a27334541262e8513">translate</a> (<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;, const <a class="el" href="classvector3.html">vector3</a>&lt;&gt; &amp;r)</td></tr>
<tr class="memdesc:gadde3201543eec30a27334541262e8513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate by vector r in Cartesian coordinates. <br /></td></tr>
<tr class="separator:gadde3201543eec30a27334541262e8513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0240ec90278ef844b9c9fe8797b6f12f"><td class="memItemLeft" align="right" valign="top"><a id="ga0240ec90278ef844b9c9fe8797b6f12f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga0240ec90278ef844b9c9fe8797b6f12f">translate</a> (<a class="el" href="group__DataStructures.html#gac243b4be10d9bc0b4e5b3c3339bbaf10">complexScalarFieldTilde</a> &amp;, const <a class="el" href="classvector3.html">vector3</a>&lt;&gt; &amp;r)</td></tr>
<tr class="memdesc:ga0240ec90278ef844b9c9fe8797b6f12f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate by vector r in Cartesian coordinates. <br /></td></tr>
<tr class="separator:ga0240ec90278ef844b9c9fe8797b6f12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79546ba0d7ac12699a7052cd9078062b"><td class="memItemLeft" align="right" valign="top"><a id="ga79546ba0d7ac12699a7052cd9078062b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga79546ba0d7ac12699a7052cd9078062b">multiplyBlochPhase</a> (<a class="el" href="group__DataStructures.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a> &amp;, const <a class="el" href="classvector3.html">vector3</a>&lt;&gt; &amp;k)</td></tr>
<tr class="memdesc:ga79546ba0d7ac12699a7052cd9078062b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply by Block phase for wave-vector k (in reciprocal lattice coordinates) <br /></td></tr>
<tr class="separator:ga79546ba0d7ac12699a7052cd9078062b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1abe1e7e20e216cc53c873e4859351d"><td class="memItemLeft" align="right" valign="top"><a id="gab1abe1e7e20e216cc53c873e4859351d"></a>
<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gab1abe1e7e20e216cc53c873e4859351d">radialFunction</a> (const <a class="el" href="classGridInfo.html">GridInfo</a> &amp;gInfo, const <a class="el" href="structRadialFunctionG.html">RadialFunctionG</a> &amp;f, <a class="el" href="classvector3.html">vector3</a>&lt;&gt; r0)</td></tr>
<tr class="memdesc:gab1abe1e7e20e216cc53c873e4859351d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create spherically-symmetric scalar field from radial form f, centered at lattice coordinates r0. <br /></td></tr>
<tr class="separator:gab1abe1e7e20e216cc53c873e4859351d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ad6e4116d1e13ad56d8db567923fe53"><td class="memItemLeft" align="right" valign="top"><a id="ga0ad6e4116d1e13ad56d8db567923fe53"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga0ad6e4116d1e13ad56d8db567923fe53">radialFunctionG</a> (const <a class="el" href="structRadialFunctionG.html">RadialFunctionG</a> &amp;f, <a class="el" href="structRealKernel.html">RealKernel</a> &amp;Kernel)</td></tr>
<tr class="memdesc:ga0ad6e4116d1e13ad56d8db567923fe53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a spherically-symmetric <a class="el" href="structRealKernel.html" title="Special class for storing real reciprocal-space kernels encountered ever so often for convolutions.">RealKernel</a> from its radial form f. <br /></td></tr>
<tr class="separator:ga0ad6e4116d1e13ad56d8db567923fe53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga863b1f8ec326f0263724a0c948a034fa"><td class="memItemLeft" align="right" valign="top"><a id="ga863b1f8ec326f0263724a0c948a034fa"></a>
<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga863b1f8ec326f0263724a0c948a034fa">radialFunctionG</a> (const <a class="el" href="classGridInfo.html">GridInfo</a> &amp;gInfo, const <a class="el" href="structRadialFunctionG.html">RadialFunctionG</a> &amp;f, <a class="el" href="classvector3.html">vector3</a>&lt;&gt; r0)</td></tr>
<tr class="memdesc:ga863b1f8ec326f0263724a0c948a034fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create spherically-symmetric scalar field from radial form f, centered at lattice coordinates r0. <br /></td></tr>
<tr class="separator:ga863b1f8ec326f0263724a0c948a034fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaaea7b606153eb02bd60810b06e6883"><td class="memItemLeft" align="right" valign="top"><a id="gaeaaea7b606153eb02bd60810b06e6883"></a>
<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaeaaea7b606153eb02bd60810b06e6883">operator*</a> (const <a class="el" href="structRadialFunctionG.html">RadialFunctionG</a> &amp;, const <a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;)</td></tr>
<tr class="memdesc:gaeaaea7b606153eb02bd60810b06e6883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve a scalar field by a radial function (preserve input) <br /></td></tr>
<tr class="separator:gaeaaea7b606153eb02bd60810b06e6883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga159ffca6ee0dd5c16fd2a36fbdaa2a2a"><td class="memItemLeft" align="right" valign="top"><a id="ga159ffca6ee0dd5c16fd2a36fbdaa2a2a"></a>
<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga159ffca6ee0dd5c16fd2a36fbdaa2a2a">operator*</a> (const <a class="el" href="structRadialFunctionG.html">RadialFunctionG</a> &amp;, <a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;&amp;)</td></tr>
<tr class="memdesc:ga159ffca6ee0dd5c16fd2a36fbdaa2a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve a scalar field by a radial function (destructible input) <br /></td></tr>
<tr class="separator:ga159ffca6ee0dd5c16fd2a36fbdaa2a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadea0d8a4783209805f865e6d96efb8e2"><td class="memItemLeft" align="right" valign="top"><a id="gadea0d8a4783209805f865e6d96efb8e2"></a>
<a class="el" href="classmatrix3.html">matrix3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gadea0d8a4783209805f865e6d96efb8e2">convolveStress</a> (const <a class="el" href="structRadialFunctionG.html">RadialFunctionG</a> &amp;w, const <a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;X, const <a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;Y)</td></tr>
<tr class="memdesc:gadea0d8a4783209805f865e6d96efb8e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">stress due to dot(X,O(w*Y)) <br /></td></tr>
<tr class="separator:gadea0d8a4783209805f865e6d96efb8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fd4afc7bf412b2a98f00ca9599a59d6"><td class="memItemLeft" align="right" valign="top"><a id="ga4fd4afc7bf412b2a98f00ca9599a59d6"></a>
<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga4fd4afc7bf412b2a98f00ca9599a59d6">exp</a> (const <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;)</td></tr>
<tr class="memdesc:ga4fd4afc7bf412b2a98f00ca9599a59d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise exponential (preserve input) <br /></td></tr>
<tr class="separator:ga4fd4afc7bf412b2a98f00ca9599a59d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34a410cc2b2d0e765f380704a1454f0c"><td class="memItemLeft" align="right" valign="top"><a id="ga34a410cc2b2d0e765f380704a1454f0c"></a>
<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga34a410cc2b2d0e765f380704a1454f0c">exp</a> (<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;&amp;)</td></tr>
<tr class="memdesc:ga34a410cc2b2d0e765f380704a1454f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise exponential (destructible input) <br /></td></tr>
<tr class="separator:ga34a410cc2b2d0e765f380704a1454f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa64b9d74b134b3fae88fdf46664cb4c6"><td class="memItemLeft" align="right" valign="top"><a id="gaa64b9d74b134b3fae88fdf46664cb4c6"></a>
<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaa64b9d74b134b3fae88fdf46664cb4c6">log</a> (const <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;)</td></tr>
<tr class="memdesc:gaa64b9d74b134b3fae88fdf46664cb4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise logarithm (preserve input) <br /></td></tr>
<tr class="separator:gaa64b9d74b134b3fae88fdf46664cb4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52e644af4f4dceb2eddcc6316886232b"><td class="memItemLeft" align="right" valign="top"><a id="ga52e644af4f4dceb2eddcc6316886232b"></a>
<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga52e644af4f4dceb2eddcc6316886232b">log</a> (<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;&amp;)</td></tr>
<tr class="memdesc:ga52e644af4f4dceb2eddcc6316886232b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise logarithm (destructible input) <br /></td></tr>
<tr class="separator:ga52e644af4f4dceb2eddcc6316886232b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6f1c9912c0c31b376cf885f5a416584"><td class="memItemLeft" align="right" valign="top"><a id="gaf6f1c9912c0c31b376cf885f5a416584"></a>
<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaf6f1c9912c0c31b376cf885f5a416584">sqrt</a> (const <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;)</td></tr>
<tr class="memdesc:gaf6f1c9912c0c31b376cf885f5a416584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise square root (preserve input) <br /></td></tr>
<tr class="separator:gaf6f1c9912c0c31b376cf885f5a416584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga599f994f39728032d389710de8cfd28f"><td class="memItemLeft" align="right" valign="top"><a id="ga599f994f39728032d389710de8cfd28f"></a>
<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga599f994f39728032d389710de8cfd28f">sqrt</a> (<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;&amp;)</td></tr>
<tr class="memdesc:ga599f994f39728032d389710de8cfd28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise square root (destructible input) <br /></td></tr>
<tr class="separator:ga599f994f39728032d389710de8cfd28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga552fff0c5ef39bb77d1e7a597e125f25"><td class="memItemLeft" align="right" valign="top"><a id="ga552fff0c5ef39bb77d1e7a597e125f25"></a>
<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga552fff0c5ef39bb77d1e7a597e125f25">inv</a> (const <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;)</td></tr>
<tr class="memdesc:ga552fff0c5ef39bb77d1e7a597e125f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise reciprocal (preserve input) <br /></td></tr>
<tr class="separator:ga552fff0c5ef39bb77d1e7a597e125f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacddc36faacbda0b7a685b09bef7104af"><td class="memItemLeft" align="right" valign="top"><a id="gacddc36faacbda0b7a685b09bef7104af"></a>
<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gacddc36faacbda0b7a685b09bef7104af">inv</a> (<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;&amp;)</td></tr>
<tr class="memdesc:gacddc36faacbda0b7a685b09bef7104af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise reciprocal (destructible input) <br /></td></tr>
<tr class="separator:gacddc36faacbda0b7a685b09bef7104af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaf5bf5049a80cf28b125aef3ede245c"><td class="memItemLeft" align="right" valign="top"><a id="gafaf5bf5049a80cf28b125aef3ede245c"></a>
<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gafaf5bf5049a80cf28b125aef3ede245c">pow</a> (const <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;, double alpha)</td></tr>
<tr class="memdesc:gafaf5bf5049a80cf28b125aef3ede245c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise power (preserve input) <br /></td></tr>
<tr class="separator:gafaf5bf5049a80cf28b125aef3ede245c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga499fcbc8528b9b777a3bdb2697fadde3"><td class="memItemLeft" align="right" valign="top"><a id="ga499fcbc8528b9b777a3bdb2697fadde3"></a>
<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga499fcbc8528b9b777a3bdb2697fadde3">pow</a> (<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;&amp;, double alpha)</td></tr>
<tr class="memdesc:ga499fcbc8528b9b777a3bdb2697fadde3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise power (destructible input) <br /></td></tr>
<tr class="separator:ga499fcbc8528b9b777a3bdb2697fadde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f6d42459ed7fcec653815e68bc6c8c2"><td class="memTemplParams" colspan="2"><a id="ga5f6d42459ed7fcec653815e68bc6c8c2"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga5f6d42459ed7fcec653815e68bc6c8c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga5f6d42459ed7fcec653815e68bc6c8c2">clone</a> (const <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;X)</td></tr>
<tr class="memdesc:ga5f6d42459ed7fcec653815e68bc6c8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone (NOTE: operator= is by reference for the ScalarField classes) <br /></td></tr>
<tr class="separator:ga5f6d42459ed7fcec653815e68bc6c8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b95a13a6713e7a8f7ebcf2fafe4f0fa"><td class="memTemplParams" colspan="2"><a id="ga6b95a13a6713e7a8f7ebcf2fafe4f0fa"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga6b95a13a6713e7a8f7ebcf2fafe4f0fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga6b95a13a6713e7a8f7ebcf2fafe4f0fa">operator*=</a> (<a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;in, double scaleFac)</td></tr>
<tr class="memdesc:ga6b95a13a6713e7a8f7ebcf2fafe4f0fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale. <br /></td></tr>
<tr class="separator:ga6b95a13a6713e7a8f7ebcf2fafe4f0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad316af27e80ddb99ea4adbd4323e791"><td class="memTemplParams" colspan="2"><a id="gaad316af27e80ddb99ea4adbd4323e791"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:gaad316af27e80ddb99ea4adbd4323e791"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaad316af27e80ddb99ea4adbd4323e791">operator*</a> (const <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;in, double scaleFac)</td></tr>
<tr class="memdesc:gaad316af27e80ddb99ea4adbd4323e791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar multiply (preserve input) <br /></td></tr>
<tr class="separator:gaad316af27e80ddb99ea4adbd4323e791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e6a458615b28289d5900e4c28c21bc9"><td class="memTemplParams" colspan="2"><a id="ga6e6a458615b28289d5900e4c28c21bc9"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga6e6a458615b28289d5900e4c28c21bc9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga6e6a458615b28289d5900e4c28c21bc9">operator*</a> (double scaleFac, const <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;in)</td></tr>
<tr class="memdesc:ga6e6a458615b28289d5900e4c28c21bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar multiply (preserve input) <br /></td></tr>
<tr class="separator:ga6e6a458615b28289d5900e4c28c21bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac47a410abfff42f35a24c7313d609833"><td class="memTemplParams" colspan="2"><a id="gac47a410abfff42f35a24c7313d609833"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:gac47a410abfff42f35a24c7313d609833"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#gac47a410abfff42f35a24c7313d609833">operator*</a> (<a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;&amp;in, double scaleFac)</td></tr>
<tr class="memdesc:gac47a410abfff42f35a24c7313d609833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar multiply (destructible input) <br /></td></tr>
<tr class="separator:gac47a410abfff42f35a24c7313d609833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabef1048c196f79b8721bac30bad7216e"><td class="memTemplParams" colspan="2"><a id="gabef1048c196f79b8721bac30bad7216e"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:gabef1048c196f79b8721bac30bad7216e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#gabef1048c196f79b8721bac30bad7216e">operator*</a> (double scaleFac, <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;&amp;in)</td></tr>
<tr class="memdesc:gabef1048c196f79b8721bac30bad7216e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar multiply (destructible input) <br /></td></tr>
<tr class="separator:gabef1048c196f79b8721bac30bad7216e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3bc7c38cba04c3db26488e3654c8366"><td class="memTemplParams" colspan="2"><a id="gaf3bc7c38cba04c3db26488e3654c8366"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:gaf3bc7c38cba04c3db26488e3654c8366"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaf3bc7c38cba04c3db26488e3654c8366">conj</a> (<a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;&amp;in)</td></tr>
<tr class="memdesc:gaf3bc7c38cba04c3db26488e3654c8366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic elementwise conjugate for complex data: <br /></td></tr>
<tr class="separator:gaf3bc7c38cba04c3db26488e3654c8366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2de969b67b67e5f6cd2f50a6ce599df"><td class="memTemplParams" colspan="2"><a id="gaa2de969b67b67e5f6cd2f50a6ce599df"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:gaa2de969b67b67e5f6cd2f50a6ce599df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>conj</b> (const <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;in)</td></tr>
<tr class="separator:gaa2de969b67b67e5f6cd2f50a6ce599df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf43aba0a87d8f91f93602e239f1c40a"><td class="memTemplParams" colspan="2"><a id="gacf43aba0a87d8f91f93602e239f1c40a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:gacf43aba0a87d8f91f93602e239f1c40a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#gacf43aba0a87d8f91f93602e239f1c40a">operator*=</a> (<a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;in, const <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;other)</td></tr>
<tr class="memdesc:gacf43aba0a87d8f91f93602e239f1c40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic elementwise multiply for complex data: <br /></td></tr>
<tr class="separator:gacf43aba0a87d8f91f93602e239f1c40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d1b6d3a371893488f8906f70a39424d"><td class="memItemLeft" align="right" valign="top"><a id="ga0d1b6d3a371893488f8906f70a39424d"></a>
<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga0d1b6d3a371893488f8906f70a39424d">operator*=</a> (<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;in, const <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;other)</td></tr>
<tr class="memdesc:ga0d1b6d3a371893488f8906f70a39424d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise multiply for real data. <br /></td></tr>
<tr class="separator:ga0d1b6d3a371893488f8906f70a39424d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cac5300f19f6501731dd9837db2dea2"><td class="memTemplParams" colspan="2"><a id="ga4cac5300f19f6501731dd9837db2dea2"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga4cac5300f19f6501731dd9837db2dea2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga4cac5300f19f6501731dd9837db2dea2">operator*</a> (const <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;in1, const <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;in2)</td></tr>
<tr class="memdesc:ga4cac5300f19f6501731dd9837db2dea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise multiply (preserve inputs) <br /></td></tr>
<tr class="separator:ga4cac5300f19f6501731dd9837db2dea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98a00ac70d945fa293f0d474a6255842"><td class="memTemplParams" colspan="2"><a id="ga98a00ac70d945fa293f0d474a6255842"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga98a00ac70d945fa293f0d474a6255842"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga98a00ac70d945fa293f0d474a6255842">operator*</a> (const <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;in1, <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;&amp;in2)</td></tr>
<tr class="memdesc:ga98a00ac70d945fa293f0d474a6255842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise multiply (destructible input) <br /></td></tr>
<tr class="separator:ga98a00ac70d945fa293f0d474a6255842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14406cf5364dc892077007f12bcbc646"><td class="memTemplParams" colspan="2"><a id="ga14406cf5364dc892077007f12bcbc646"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga14406cf5364dc892077007f12bcbc646"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga14406cf5364dc892077007f12bcbc646">operator*</a> (<a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;&amp;in1, const <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;in2)</td></tr>
<tr class="memdesc:ga14406cf5364dc892077007f12bcbc646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise multiply (destructible input) <br /></td></tr>
<tr class="separator:ga14406cf5364dc892077007f12bcbc646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78cfc5149841c5989f7468b7268438dc"><td class="memTemplParams" colspan="2"><a id="ga78cfc5149841c5989f7468b7268438dc"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga78cfc5149841c5989f7468b7268438dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga78cfc5149841c5989f7468b7268438dc">operator*</a> (<a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;&amp;in1, <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;&amp;in2)</td></tr>
<tr class="memdesc:ga78cfc5149841c5989f7468b7268438dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise multiply (destructible inputs) <br /></td></tr>
<tr class="separator:ga78cfc5149841c5989f7468b7268438dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3964c0a9598b4a3c7d7446172a6bf218"><td class="memItemLeft" align="right" valign="top"><a id="ga3964c0a9598b4a3c7d7446172a6bf218"></a>
<a class="el" href="group__DataStructures.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga3964c0a9598b4a3c7d7446172a6bf218">operator*=</a> (<a class="el" href="group__DataStructures.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a> &amp;, const <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;)</td></tr>
<tr class="memdesc:ga3964c0a9598b4a3c7d7446172a6bf218"><td class="mdescLeft">&#160;</td><td class="mdescRight">elementwise multiply <br /></td></tr>
<tr class="separator:ga3964c0a9598b4a3c7d7446172a6bf218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95fc7e50aa67b79c396b3910e22afce6"><td class="memItemLeft" align="right" valign="top"><a id="ga95fc7e50aa67b79c396b3910e22afce6"></a>
<a class="el" href="group__DataStructures.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga95fc7e50aa67b79c396b3910e22afce6">operator*</a> (const <a class="el" href="group__DataStructures.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a> &amp;, const <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;)</td></tr>
<tr class="memdesc:ga95fc7e50aa67b79c396b3910e22afce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">elementwise multiply (preserve inputs) <br /></td></tr>
<tr class="separator:ga95fc7e50aa67b79c396b3910e22afce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga822443936122e41d048e4cc0d3ad10b1"><td class="memItemLeft" align="right" valign="top"><a id="ga822443936122e41d048e4cc0d3ad10b1"></a>
<a class="el" href="group__DataStructures.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga822443936122e41d048e4cc0d3ad10b1">operator*</a> (const <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;, const <a class="el" href="group__DataStructures.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a> &amp;)</td></tr>
<tr class="memdesc:ga822443936122e41d048e4cc0d3ad10b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">elementwise multiply (preserve inputs) <br /></td></tr>
<tr class="separator:ga822443936122e41d048e4cc0d3ad10b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28ad6798c2a5943034beb87b0af884a3"><td class="memItemLeft" align="right" valign="top"><a id="ga28ad6798c2a5943034beb87b0af884a3"></a>
<a class="el" href="group__DataStructures.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga28ad6798c2a5943034beb87b0af884a3">operator*</a> (<a class="el" href="group__DataStructures.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a> &amp;&amp;, const <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;)</td></tr>
<tr class="memdesc:ga28ad6798c2a5943034beb87b0af884a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">elementwise multiply (destructible inputs) <br /></td></tr>
<tr class="separator:ga28ad6798c2a5943034beb87b0af884a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b4ee8f3a35b6c59f41da3d822e20f94"><td class="memItemLeft" align="right" valign="top"><a id="ga2b4ee8f3a35b6c59f41da3d822e20f94"></a>
<a class="el" href="group__DataStructures.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga2b4ee8f3a35b6c59f41da3d822e20f94">operator*</a> (const <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;, <a class="el" href="group__DataStructures.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a> &amp;&amp;)</td></tr>
<tr class="memdesc:ga2b4ee8f3a35b6c59f41da3d822e20f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">elementwise multiply (destructible inputs) <br /></td></tr>
<tr class="separator:ga2b4ee8f3a35b6c59f41da3d822e20f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06f4e7a26509a7435a1263a2a594e609"><td class="memItemLeft" align="right" valign="top"><a id="ga06f4e7a26509a7435a1263a2a594e609"></a>
<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga06f4e7a26509a7435a1263a2a594e609">operator*=</a> (<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;, const <a class="el" href="structRealKernel.html">RealKernel</a> &amp;)</td></tr>
<tr class="memdesc:ga06f4e7a26509a7435a1263a2a594e609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise multiply. <br /></td></tr>
<tr class="separator:ga06f4e7a26509a7435a1263a2a594e609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga886f3090cf360e31228ffe596f3f892f"><td class="memItemLeft" align="right" valign="top"><a id="ga886f3090cf360e31228ffe596f3f892f"></a>
<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga886f3090cf360e31228ffe596f3f892f">operator*</a> (const <a class="el" href="structRealKernel.html">RealKernel</a> &amp;, const <a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;)</td></tr>
<tr class="memdesc:ga886f3090cf360e31228ffe596f3f892f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise multiply (preserve inputs) <br /></td></tr>
<tr class="separator:ga886f3090cf360e31228ffe596f3f892f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1295528b249776bf8d34ffd70770324"><td class="memItemLeft" align="right" valign="top"><a id="gaa1295528b249776bf8d34ffd70770324"></a>
<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaa1295528b249776bf8d34ffd70770324">operator*</a> (const <a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;, const <a class="el" href="structRealKernel.html">RealKernel</a> &amp;)</td></tr>
<tr class="memdesc:gaa1295528b249776bf8d34ffd70770324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise multiply (preserve inputs) <br /></td></tr>
<tr class="separator:gaa1295528b249776bf8d34ffd70770324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf924d4d59d926c258ec8a4b0ab3ea402"><td class="memItemLeft" align="right" valign="top"><a id="gaf924d4d59d926c258ec8a4b0ab3ea402"></a>
<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaf924d4d59d926c258ec8a4b0ab3ea402">operator*</a> (const <a class="el" href="structRealKernel.html">RealKernel</a> &amp;, <a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;&amp;)</td></tr>
<tr class="memdesc:gaf924d4d59d926c258ec8a4b0ab3ea402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise multiply (destructible input) <br /></td></tr>
<tr class="separator:gaf924d4d59d926c258ec8a4b0ab3ea402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5b56721d16c4d6a8721b2b4745f226e"><td class="memItemLeft" align="right" valign="top"><a id="gab5b56721d16c4d6a8721b2b4745f226e"></a>
<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gab5b56721d16c4d6a8721b2b4745f226e">operator*</a> (<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;&amp;, const <a class="el" href="structRealKernel.html">RealKernel</a> &amp;)</td></tr>
<tr class="memdesc:gab5b56721d16c4d6a8721b2b4745f226e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise multiply (destructible input) <br /></td></tr>
<tr class="separator:gab5b56721d16c4d6a8721b2b4745f226e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga347d66dc69dd8703c75adb28188806d6"><td class="memTemplParams" colspan="2"><a id="ga347d66dc69dd8703c75adb28188806d6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga347d66dc69dd8703c75adb28188806d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga347d66dc69dd8703c75adb28188806d6">axpy</a> (double alpha, const <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;X, <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;Y)</td></tr>
<tr class="memdesc:ga347d66dc69dd8703c75adb28188806d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic axpy for complex data types (Note: null pointers are treated as zero) <br /></td></tr>
<tr class="separator:ga347d66dc69dd8703c75adb28188806d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f016fc2f3c65605f533ac7a40344624"><td class="memItemLeft" align="right" valign="top"><a id="ga1f016fc2f3c65605f533ac7a40344624"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga1f016fc2f3c65605f533ac7a40344624">axpy</a> (double alpha, const <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;X, <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;Y)</td></tr>
<tr class="memdesc:ga1f016fc2f3c65605f533ac7a40344624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real data Linear combine: Y += alpha * X (Note: null pointers are treated as zero) <br /></td></tr>
<tr class="separator:ga1f016fc2f3c65605f533ac7a40344624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae756725df1bc186786de9a0f44a55e3f"><td class="memTemplParams" colspan="2"><a id="gae756725df1bc186786de9a0f44a55e3f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:gae756725df1bc186786de9a0f44a55e3f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#gae756725df1bc186786de9a0f44a55e3f">operator+=</a> (<a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;in, const <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;other)</td></tr>
<tr class="memdesc:gae756725df1bc186786de9a0f44a55e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment. <br /></td></tr>
<tr class="separator:gae756725df1bc186786de9a0f44a55e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3d01ae7a5af72c95bbc9300632e69c2"><td class="memTemplParams" colspan="2"><a id="gac3d01ae7a5af72c95bbc9300632e69c2"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:gac3d01ae7a5af72c95bbc9300632e69c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#gac3d01ae7a5af72c95bbc9300632e69c2">operator-=</a> (<a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;in, const <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;other)</td></tr>
<tr class="memdesc:gac3d01ae7a5af72c95bbc9300632e69c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement. <br /></td></tr>
<tr class="separator:gac3d01ae7a5af72c95bbc9300632e69c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04a7fa6ffc22d4a17c690bf3c538c377"><td class="memTemplParams" colspan="2"><a id="ga04a7fa6ffc22d4a17c690bf3c538c377"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga04a7fa6ffc22d4a17c690bf3c538c377"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga04a7fa6ffc22d4a17c690bf3c538c377">operator+</a> (const <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;in1, const <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;in2)</td></tr>
<tr class="memdesc:ga04a7fa6ffc22d4a17c690bf3c538c377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add (preserve inputs) <br /></td></tr>
<tr class="separator:ga04a7fa6ffc22d4a17c690bf3c538c377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1409712a1a236190917826a850623c43"><td class="memTemplParams" colspan="2"><a id="ga1409712a1a236190917826a850623c43"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga1409712a1a236190917826a850623c43"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga1409712a1a236190917826a850623c43">operator+</a> (const <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;in1, <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;&amp;in2)</td></tr>
<tr class="memdesc:ga1409712a1a236190917826a850623c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add (destructible input) <br /></td></tr>
<tr class="separator:ga1409712a1a236190917826a850623c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2429e1bc8a8dc6c33d3897a037d50a3"><td class="memTemplParams" colspan="2"><a id="gae2429e1bc8a8dc6c33d3897a037d50a3"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:gae2429e1bc8a8dc6c33d3897a037d50a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#gae2429e1bc8a8dc6c33d3897a037d50a3">operator+</a> (<a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;&amp;in1, const <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;in2)</td></tr>
<tr class="memdesc:gae2429e1bc8a8dc6c33d3897a037d50a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add (destructible input) <br /></td></tr>
<tr class="separator:gae2429e1bc8a8dc6c33d3897a037d50a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a08a1b978e355bd3abd3428f7486446"><td class="memTemplParams" colspan="2"><a id="ga8a08a1b978e355bd3abd3428f7486446"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga8a08a1b978e355bd3abd3428f7486446"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga8a08a1b978e355bd3abd3428f7486446">operator+</a> (<a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;&amp;in1, <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;&amp;in2)</td></tr>
<tr class="memdesc:ga8a08a1b978e355bd3abd3428f7486446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add (destructible inputs) <br /></td></tr>
<tr class="separator:ga8a08a1b978e355bd3abd3428f7486446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab18629e8a59526fdc22081111a22825a"><td class="memTemplParams" colspan="2"><a id="gab18629e8a59526fdc22081111a22825a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:gab18629e8a59526fdc22081111a22825a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#gab18629e8a59526fdc22081111a22825a">operator-</a> (const <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;in1, const <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;in2)</td></tr>
<tr class="memdesc:gab18629e8a59526fdc22081111a22825a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract (preserve inputs) <br /></td></tr>
<tr class="separator:gab18629e8a59526fdc22081111a22825a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a7fe4d328e4fcf5727dcafceb44b7b5"><td class="memTemplParams" colspan="2"><a id="ga8a7fe4d328e4fcf5727dcafceb44b7b5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga8a7fe4d328e4fcf5727dcafceb44b7b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga8a7fe4d328e4fcf5727dcafceb44b7b5">operator-</a> (const <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;in1, <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;&amp;in2)</td></tr>
<tr class="memdesc:ga8a7fe4d328e4fcf5727dcafceb44b7b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract (destructible input) <br /></td></tr>
<tr class="separator:ga8a7fe4d328e4fcf5727dcafceb44b7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15f022bebde1854ef63cbadadad07461"><td class="memTemplParams" colspan="2"><a id="ga15f022bebde1854ef63cbadadad07461"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga15f022bebde1854ef63cbadadad07461"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga15f022bebde1854ef63cbadadad07461">operator-</a> (<a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;&amp;in1, const <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;in2)</td></tr>
<tr class="memdesc:ga15f022bebde1854ef63cbadadad07461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract (destructible input) <br /></td></tr>
<tr class="separator:ga15f022bebde1854ef63cbadadad07461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a8c9f5f97c59104640d72384a20c786"><td class="memTemplParams" colspan="2"><a id="ga2a8c9f5f97c59104640d72384a20c786"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga2a8c9f5f97c59104640d72384a20c786"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga2a8c9f5f97c59104640d72384a20c786">operator-</a> (<a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;&amp;in1, <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;&amp;in2)</td></tr>
<tr class="memdesc:ga2a8c9f5f97c59104640d72384a20c786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract (destructible inputs) <br /></td></tr>
<tr class="separator:ga2a8c9f5f97c59104640d72384a20c786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25931ff6157dd8dd0e37a8618c46ce89"><td class="memTemplParams" colspan="2"><a id="ga25931ff6157dd8dd0e37a8618c46ce89"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga25931ff6157dd8dd0e37a8618c46ce89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga25931ff6157dd8dd0e37a8618c46ce89">operator-</a> (const <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;in)</td></tr>
<tr class="memdesc:ga25931ff6157dd8dd0e37a8618c46ce89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate. <br /></td></tr>
<tr class="separator:ga25931ff6157dd8dd0e37a8618c46ce89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga087c09a150f569e8b643186dc73e1400"><td class="memTemplParams" colspan="2"><a id="ga087c09a150f569e8b643186dc73e1400"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga087c09a150f569e8b643186dc73e1400"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga087c09a150f569e8b643186dc73e1400">operator-</a> (<a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;&amp;in)</td></tr>
<tr class="memdesc:ga087c09a150f569e8b643186dc73e1400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate. <br /></td></tr>
<tr class="separator:ga087c09a150f569e8b643186dc73e1400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77c16eb8c287179b49d4833f9bf90fd3"><td class="memItemLeft" align="right" valign="top"><a id="ga77c16eb8c287179b49d4833f9bf90fd3"></a>
<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga77c16eb8c287179b49d4833f9bf90fd3">operator+=</a> (<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;, double)</td></tr>
<tr class="memdesc:ga77c16eb8c287179b49d4833f9bf90fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment by scalar. <br /></td></tr>
<tr class="separator:ga77c16eb8c287179b49d4833f9bf90fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ab6caf319eb8080a60331b5b86ed072"><td class="memItemLeft" align="right" valign="top"><a id="ga7ab6caf319eb8080a60331b5b86ed072"></a>
<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga7ab6caf319eb8080a60331b5b86ed072">operator+</a> (double, const <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;)</td></tr>
<tr class="memdesc:ga7ab6caf319eb8080a60331b5b86ed072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add scalar (preserve inputs) <br /></td></tr>
<tr class="separator:ga7ab6caf319eb8080a60331b5b86ed072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31266d8d8460f214422cf4c6c7c7d394"><td class="memItemLeft" align="right" valign="top"><a id="ga31266d8d8460f214422cf4c6c7c7d394"></a>
<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga31266d8d8460f214422cf4c6c7c7d394">operator+</a> (const <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;, double)</td></tr>
<tr class="memdesc:ga31266d8d8460f214422cf4c6c7c7d394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add scalar (preserve inputs) <br /></td></tr>
<tr class="separator:ga31266d8d8460f214422cf4c6c7c7d394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81442e3e514477b08799fe43058cb398"><td class="memItemLeft" align="right" valign="top"><a id="ga81442e3e514477b08799fe43058cb398"></a>
<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga81442e3e514477b08799fe43058cb398">operator+</a> (double, <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;&amp;)</td></tr>
<tr class="memdesc:ga81442e3e514477b08799fe43058cb398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add scalar (destructible input) <br /></td></tr>
<tr class="separator:ga81442e3e514477b08799fe43058cb398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d05f53cbda9a4ca339442228d9f100a"><td class="memItemLeft" align="right" valign="top"><a id="ga7d05f53cbda9a4ca339442228d9f100a"></a>
<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga7d05f53cbda9a4ca339442228d9f100a">operator+</a> (<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;&amp;, double)</td></tr>
<tr class="memdesc:ga7d05f53cbda9a4ca339442228d9f100a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add scalar (destructible input) <br /></td></tr>
<tr class="separator:ga7d05f53cbda9a4ca339442228d9f100a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfc2ace8cd5e843bd5052af36442a752"><td class="memItemLeft" align="right" valign="top"><a id="gabfc2ace8cd5e843bd5052af36442a752"></a>
<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gabfc2ace8cd5e843bd5052af36442a752">operator-=</a> (<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;, double)</td></tr>
<tr class="memdesc:gabfc2ace8cd5e843bd5052af36442a752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement by scalar. <br /></td></tr>
<tr class="separator:gabfc2ace8cd5e843bd5052af36442a752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a63c6e87ba986f5d2b81e7ae99d3901"><td class="memItemLeft" align="right" valign="top"><a id="ga1a63c6e87ba986f5d2b81e7ae99d3901"></a>
<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga1a63c6e87ba986f5d2b81e7ae99d3901">operator-</a> (double, const <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;)</td></tr>
<tr class="memdesc:ga1a63c6e87ba986f5d2b81e7ae99d3901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract from scalar (preserve inputs) <br /></td></tr>
<tr class="separator:ga1a63c6e87ba986f5d2b81e7ae99d3901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad678ea601e42bcef68f0041d4c11be27"><td class="memItemLeft" align="right" valign="top"><a id="gad678ea601e42bcef68f0041d4c11be27"></a>
<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gad678ea601e42bcef68f0041d4c11be27">operator-</a> (const <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;, double)</td></tr>
<tr class="memdesc:gad678ea601e42bcef68f0041d4c11be27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract scalar (preserve inputs) <br /></td></tr>
<tr class="separator:gad678ea601e42bcef68f0041d4c11be27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3563e8a1fcef5562ba28c3e2ece602db"><td class="memItemLeft" align="right" valign="top"><a id="ga3563e8a1fcef5562ba28c3e2ece602db"></a>
<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga3563e8a1fcef5562ba28c3e2ece602db">operator-</a> (double, <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;&amp;)</td></tr>
<tr class="memdesc:ga3563e8a1fcef5562ba28c3e2ece602db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract from scalar (destructible input) <br /></td></tr>
<tr class="separator:ga3563e8a1fcef5562ba28c3e2ece602db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab953515c96b6feb2831e58cc34205d8a"><td class="memItemLeft" align="right" valign="top"><a id="gab953515c96b6feb2831e58cc34205d8a"></a>
<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gab953515c96b6feb2831e58cc34205d8a">operator-</a> (<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;&amp;, double)</td></tr>
<tr class="memdesc:gab953515c96b6feb2831e58cc34205d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract scalar (destructible input) <br /></td></tr>
<tr class="separator:gab953515c96b6feb2831e58cc34205d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43806a2060cb902a2f0f869702ec3a89"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga43806a2060cb902a2f0f869702ec3a89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcomplex.html">complex</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga43806a2060cb902a2f0f869702ec3a89">dot</a> (const <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;X, const <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;Y)</td></tr>
<tr class="separator:ga43806a2060cb902a2f0f869702ec3a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f28a65ff8c0f48d2d04129b16c4111d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8f28a65ff8c0f48d2d04129b16c4111d"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga8f28a65ff8c0f48d2d04129b16c4111d">nrm2</a> (const <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;X)</td></tr>
<tr class="separator:ga8f28a65ff8c0f48d2d04129b16c4111d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacca8fc028f3136278b6087e0f30e30b2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gacca8fc028f3136278b6087e0f30e30b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcomplex.html">complex</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#gacca8fc028f3136278b6087e0f30e30b2">sum</a> (const <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;X)</td></tr>
<tr class="separator:gacca8fc028f3136278b6087e0f30e30b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e193aad78f2e545e261dad3953451ed"><td class="memItemLeft" align="right" valign="top"><a id="ga5e193aad78f2e545e261dad3953451ed"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga5e193aad78f2e545e261dad3953451ed">dot</a> (const <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;, const <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;)</td></tr>
<tr class="memdesc:ga5e193aad78f2e545e261dad3953451ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inner product. <br /></td></tr>
<tr class="separator:ga5e193aad78f2e545e261dad3953451ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51b73a13b7636ddfe5cf25755dd2d1c7"><td class="memItemLeft" align="right" valign="top"><a id="ga51b73a13b7636ddfe5cf25755dd2d1c7"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga51b73a13b7636ddfe5cf25755dd2d1c7">dot</a> (const <a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;, const <a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;)</td></tr>
<tr class="memdesc:ga51b73a13b7636ddfe5cf25755dd2d1c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inner product. <br /></td></tr>
<tr class="separator:ga51b73a13b7636ddfe5cf25755dd2d1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbfc4ae55665340f85e171cccce8ff43"><td class="memItemLeft" align="right" valign="top"><a id="gadbfc4ae55665340f85e171cccce8ff43"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gadbfc4ae55665340f85e171cccce8ff43">nrm2</a> (const <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;)</td></tr>
<tr class="memdesc:gadbfc4ae55665340f85e171cccce8ff43"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-norm <br /></td></tr>
<tr class="separator:gadbfc4ae55665340f85e171cccce8ff43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9202828c80f1bf05e1ae37747c76097"><td class="memItemLeft" align="right" valign="top"><a id="gaa9202828c80f1bf05e1ae37747c76097"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaa9202828c80f1bf05e1ae37747c76097">nrm2</a> (const <a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;)</td></tr>
<tr class="memdesc:gaa9202828c80f1bf05e1ae37747c76097"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-norm <br /></td></tr>
<tr class="separator:gaa9202828c80f1bf05e1ae37747c76097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga369926574f0cba30653d0c5230ce144a"><td class="memItemLeft" align="right" valign="top"><a id="ga369926574f0cba30653d0c5230ce144a"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga369926574f0cba30653d0c5230ce144a">sum</a> (const <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;)</td></tr>
<tr class="memdesc:ga369926574f0cba30653d0c5230ce144a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of elements. <br /></td></tr>
<tr class="separator:ga369926574f0cba30653d0c5230ce144a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49a7bd915e80df1dbae9cd395f23d0fb"><td class="memItemLeft" align="right" valign="top"><a id="ga49a7bd915e80df1dbae9cd395f23d0fb"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga49a7bd915e80df1dbae9cd395f23d0fb">sum</a> (const <a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;)</td></tr>
<tr class="memdesc:ga49a7bd915e80df1dbae9cd395f23d0fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="group__Operators.html#ga43806a2060cb902a2f0f869702ec3a89">dot()</a> with a ScalarFieldTilde of all 1s (NOTE: sum(X) != sum(I(X))) <br /></td></tr>
<tr class="separator:ga49a7bd915e80df1dbae9cd395f23d0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad534d221a7b482ff0a3e056993a411a8"><td class="memItemLeft" align="right" valign="top"><a id="gad534d221a7b482ff0a3e056993a411a8"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gad534d221a7b482ff0a3e056993a411a8">integral</a> (const <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;)</td></tr>
<tr class="memdesc:gad534d221a7b482ff0a3e056993a411a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integral in the unit cell (dV times <a class="el" href="group__Operators.html#gacca8fc028f3136278b6087e0f30e30b2">sum()</a>) <br /></td></tr>
<tr class="separator:gad534d221a7b482ff0a3e056993a411a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56d6ddba1140a2ea91fb5a206f682baf"><td class="memItemLeft" align="right" valign="top"><a id="ga56d6ddba1140a2ea91fb5a206f682baf"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga56d6ddba1140a2ea91fb5a206f682baf">integral</a> (const <a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;)</td></tr>
<tr class="memdesc:ga56d6ddba1140a2ea91fb5a206f682baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integral in the unit cell (just fetches the G=0 component with correct prefactor) <br /></td></tr>
<tr class="separator:ga56d6ddba1140a2ea91fb5a206f682baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97a2ffbd5a9525ac54446318efd3532c"><td class="memItemLeft" align="right" valign="top"><a id="ga97a2ffbd5a9525ac54446318efd3532c"></a>
<a class="el" href="structcomplex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga97a2ffbd5a9525ac54446318efd3532c">integral</a> (const <a class="el" href="group__DataStructures.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a> &amp;)</td></tr>
<tr class="memdesc:ga97a2ffbd5a9525ac54446318efd3532c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integral in the unit cell (dV times <a class="el" href="group__Operators.html#gacca8fc028f3136278b6087e0f30e30b2">sum()</a>) <br /></td></tr>
<tr class="separator:ga97a2ffbd5a9525ac54446318efd3532c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67bd6cd71d606bf612c382bd21b57f48"><td class="memItemLeft" align="right" valign="top"><a id="ga67bd6cd71d606bf612c382bd21b57f48"></a>
<a class="el" href="structcomplex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga67bd6cd71d606bf612c382bd21b57f48">integral</a> (const <a class="el" href="group__DataStructures.html#gac243b4be10d9bc0b4e5b3c3339bbaf10">complexScalarFieldTilde</a> &amp;)</td></tr>
<tr class="memdesc:ga67bd6cd71d606bf612c382bd21b57f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integral in the unit cell (just fetches the G=0 component with correct prefactor) <br /></td></tr>
<tr class="separator:ga67bd6cd71d606bf612c382bd21b57f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d15a43ade7e537eb8a4d72e4c9ec514"><td class="memItemLeft" align="right" valign="top"><a id="ga0d15a43ade7e537eb8a4d72e4c9ec514"></a>
<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><b>changeGrid</b> (const <a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;, const <a class="el" href="classGridInfo.html">GridInfo</a> &amp;gInfoNew)</td></tr>
<tr class="separator:ga0d15a43ade7e537eb8a4d72e4c9ec514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5441dc0884b963f4f2ca9cc6ca2adb41"><td class="memItemLeft" align="right" valign="top"><a id="ga5441dc0884b963f4f2ca9cc6ca2adb41"></a>
<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><b>changeGrid</b> (const <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;, const <a class="el" href="classGridInfo.html">GridInfo</a> &amp;gInfoNew)</td></tr>
<tr class="separator:ga5441dc0884b963f4f2ca9cc6ca2adb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga240eabc96d12773698ef5b31061a7905"><td class="memItemLeft" align="right" valign="top"><a id="ga240eabc96d12773698ef5b31061a7905"></a>
<a class="el" href="group__DataStructures.html#gac243b4be10d9bc0b4e5b3c3339bbaf10">complexScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><b>changeGrid</b> (const <a class="el" href="group__DataStructures.html#gac243b4be10d9bc0b4e5b3c3339bbaf10">complexScalarFieldTilde</a> &amp;, const <a class="el" href="classGridInfo.html">GridInfo</a> &amp;gInfoNew)</td></tr>
<tr class="separator:ga240eabc96d12773698ef5b31061a7905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf6e54456571b78915fca018b52083c7"><td class="memItemLeft" align="right" valign="top"><a id="gadf6e54456571b78915fca018b52083c7"></a>
<a class="el" href="group__DataStructures.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><b>changeGrid</b> (const <a class="el" href="group__DataStructures.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a> &amp;, const <a class="el" href="classGridInfo.html">GridInfo</a> &amp;gInfoNew)</td></tr>
<tr class="separator:gadf6e54456571b78915fca018b52083c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafed65e42a6b07f3eb3c815b67c13a10"><td class="memTemplParams" colspan="2"><a id="gaafed65e42a6b07f3eb3c815b67c13a10"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaafed65e42a6b07f3eb3c815b67c13a10"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>initZero</b> (<a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;X)</td></tr>
<tr class="separator:gaafed65e42a6b07f3eb3c815b67c13a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ff2e43f9f67b1376378e4f34faa357c"><td class="memTemplParams" colspan="2"><a id="ga5ff2e43f9f67b1376378e4f34faa357c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5ff2e43f9f67b1376378e4f34faa357c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>initZero</b> (<a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;X, const <a class="el" href="classGridInfo.html">GridInfo</a> &amp;gInfo)</td></tr>
<tr class="separator:ga5ff2e43f9f67b1376378e4f34faa357c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd857618a416a41557fb7a7655f70d19"><td class="memTemplParams" colspan="2"><a id="gabd857618a416a41557fb7a7655f70d19"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gabd857618a416a41557fb7a7655f70d19"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#gabd857618a416a41557fb7a7655f70d19">nullToZero</a> (<a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;X, const <a class="el" href="classGridInfo.html">GridInfo</a> &amp;gInfo)</td></tr>
<tr class="memdesc:gabd857618a416a41557fb7a7655f70d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">If X is null, allocate and initialize to 0. <br /></td></tr>
<tr class="separator:gabd857618a416a41557fb7a7655f70d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c5dd580fe5b7a81b58f59ecffa9b63c"><td class="memItemLeft" align="right" valign="top"><a id="ga9c5dd580fe5b7a81b58f59ecffa9b63c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga9c5dd580fe5b7a81b58f59ecffa9b63c">initRandom</a> (<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;, double cap=0.0)</td></tr>
<tr class="memdesc:ga9c5dd580fe5b7a81b58f59ecffa9b63c"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize element-wise with a unit-normal random number (with a cap if cap&gt;0) <br /></td></tr>
<tr class="separator:ga9c5dd580fe5b7a81b58f59ecffa9b63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7722b60b017438bb67ddfb0e62567545"><td class="memItemLeft" align="right" valign="top"><a id="ga7722b60b017438bb67ddfb0e62567545"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga7722b60b017438bb67ddfb0e62567545">initRandomFlat</a> (<a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;)</td></tr>
<tr class="memdesc:ga7722b60b017438bb67ddfb0e62567545"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize element-wise with a unit-flat [0:1) random number <br /></td></tr>
<tr class="separator:ga7722b60b017438bb67ddfb0e62567545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaba16d63130c3ce69e8b3df905b8e6bb"><td class="memItemLeft" align="right" valign="top"><a id="gaaba16d63130c3ce69e8b3df905b8e6bb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaaba16d63130c3ce69e8b3df905b8e6bb">initGaussianKernel</a> (<a class="el" href="structRealKernel.html">RealKernel</a> &amp;, double x0)</td></tr>
<tr class="memdesc:gaaba16d63130c3ce69e8b3df905b8e6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize to gaussian kernel exp(-(G x0/2)^2) <br /></td></tr>
<tr class="separator:gaaba16d63130c3ce69e8b3df905b8e6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8cb22b019500e0940c078cff97e606e"><td class="memItemLeft" align="right" valign="top"><a id="gaa8cb22b019500e0940c078cff97e606e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaa8cb22b019500e0940c078cff97e606e">initTranslation</a> (<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;, const <a class="el" href="classvector3.html">vector3</a>&lt;&gt; &amp;r)</td></tr>
<tr class="memdesc:gaa8cb22b019500e0940c078cff97e606e"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize to translation operator exp(-i G.r) <br /></td></tr>
<tr class="separator:gaa8cb22b019500e0940c078cff97e606e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81d7607460720a627c19b6a4c48fd15f"><td class="memItemLeft" align="right" valign="top"><a id="ga81d7607460720a627c19b6a4c48fd15f"></a>
<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga81d7607460720a627c19b6a4c48fd15f">gaussConvolve</a> (const <a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;, double sigma)</td></tr>
<tr class="memdesc:ga81d7607460720a627c19b6a4c48fd15f"><td class="mdescLeft">&#160;</td><td class="mdescRight">convolve with a gaussian <br /></td></tr>
<tr class="separator:ga81d7607460720a627c19b6a4c48fd15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac260b7674bb734a8c4e7c3c064038082"><td class="memItemLeft" align="right" valign="top"><a id="gac260b7674bb734a8c4e7c3c064038082"></a>
<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gac260b7674bb734a8c4e7c3c064038082">gaussConvolve</a> (<a class="el" href="group__DataStructures.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;&amp;, double sigma)</td></tr>
<tr class="memdesc:gac260b7674bb734a8c4e7c3c064038082"><td class="mdescLeft">&#160;</td><td class="mdescRight">convolve with a gaussian (destructible input) <br /></td></tr>
<tr class="separator:gac260b7674bb734a8c4e7c3c064038082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb83e3f4df940dd53315d55ef8bdffac"><td class="memTemplParams" colspan="2"><a id="gacb83e3f4df940dd53315d55ef8bdffac"></a>
template&lt;typename Func , typename... Args&gt; </td></tr>
<tr class="memitem:gacb83e3f4df940dd53315d55ef8bdffac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#gacb83e3f4df940dd53315d55ef8bdffac">applyFuncGsq</a> (const <a class="el" href="classGridInfo.html">GridInfo</a> &amp;gInfo, const Func &amp;f, Args... args)</td></tr>
<tr class="memdesc:gacb83e3f4df940dd53315d55ef8bdffac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a function f(i, Gsq, args...) at each point in reciprocal space indexed by i. <br /></td></tr>
<tr class="separator:gacb83e3f4df940dd53315d55ef8bdffac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga455d816cd7ce380cde75bfd54550025d"><td class="memTemplParams" colspan="2"><a id="ga455d816cd7ce380cde75bfd54550025d"></a>
template&lt;typename Func , typename... Args&gt; </td></tr>
<tr class="memitem:ga455d816cd7ce380cde75bfd54550025d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga455d816cd7ce380cde75bfd54550025d">applyFunc_r</a> (const <a class="el" href="classGridInfo.html">GridInfo</a> &amp;gInfo, const Func &amp;f, Args... args)</td></tr>
<tr class="memdesc:ga455d816cd7ce380cde75bfd54550025d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a function f(i, r, args...) at each point in real space index by i. <br /></td></tr>
<tr class="separator:ga455d816cd7ce380cde75bfd54550025d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bbd2f9cd2428cc4f43e609c963e6bfb"><td class="memItemLeft" align="right" valign="top"><a id="ga6bbd2f9cd2428cc4f43e609c963e6bfb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga6bbd2f9cd2428cc4f43e609c963e6bfb">printStats</a> (const <a class="el" href="group__DataStructures.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;X, const char *name, FILE *fp=stdout)</td></tr>
<tr class="memdesc:ga6bbd2f9cd2428cc4f43e609c963e6bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print mean and standard deviation of array with specified name (debug utility) <br /></td></tr>
<tr class="separator:ga6bbd2f9cd2428cc4f43e609c963e6bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b2616e16d1151e367453f38cefa751f"><td class="memTemplParams" colspan="2">template&lt;typename Callable , typename Vec &gt; </td></tr>
<tr class="memitem:ga0b2616e16d1151e367453f38cefa751f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga0b2616e16d1151e367453f38cefa751f">checkSymmetry</a> (Callable *func, const Vec &amp;v1, const Vec &amp;v2, const char *funcName)</td></tr>
<tr class="separator:ga0b2616e16d1151e367453f38cefa751f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0b2616e16d1151e367453f38cefa751f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b2616e16d1151e367453f38cefa751f">&#9670;&nbsp;</a></span>checkSymmetry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Callable , typename Vec &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void checkSymmetry </td>
          <td>(</td>
          <td class="paramtype">Callable *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vec &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vec &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>funcName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check the symmetry of a linear operator </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Callable</td><td>An operator with function call signature Vec Callable(const Vec&amp;) </td></tr>
    <tr><td class="paramname">Vec</td><td>Any operand type representing an element of a vector space </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga43806a2060cb902a2f0f869702ec3a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43806a2060cb902a2f0f869702ec3a89">&#9670;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcomplex.html">complex</a> dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Y</td><td>Generic inner product for complex types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6c1b03241b133beaed04728d26a086e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c1b03241b133beaed04728d26a086e3">&#9670;&nbsp;</a></span>eblas_accumNorm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eblas_accumNorm </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accumulate elementwise norm of a complex array x into y i.e. y += a x conj(x) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Length of array </td></tr>
    <tr><td class="paramname">a</td><td>scale factor </td></tr>
    <tr><td class="paramname">x</td><td>Input complex data array </td></tr>
    <tr><td class="paramname">y</td><td>Ouput real data array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1e140105e5e7ee1f8baaff4e6a016bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e140105e5e7ee1f8baaff4e6a016bf5">&#9670;&nbsp;</a></span>eblas_accumProd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eblas_accumProd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>xU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>xC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>yRe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>yIm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accumulate elementwise product of two complex arrays xU and xC into real and imaginary parts yRe and yIm i.e. (yRe + i yIm) += a xU conj(xC) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Length of array </td></tr>
    <tr><td class="paramname">a</td><td>scale factor </td></tr>
    <tr><td class="paramname">xU</td><td>Unconjugated input complex data array </td></tr>
    <tr><td class="paramname">xC</td><td>Conjugated input complex data array </td></tr>
    <tr><td class="paramname">yRe</td><td>Ouput real-part data array </td></tr>
    <tr><td class="paramname">yIm</td><td>Ouput imaginary-part data array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacf54b09ce097bfea9cfa343e2040c9bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf54b09ce097bfea9cfa343e2040c9bd">&#9670;&nbsp;</a></span>eblas_accumProdComplex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eblas_accumProdComplex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>xU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>xC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accumulate elementwise product of two complex arrays xU and xC into y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Length of array </td></tr>
    <tr><td class="paramname">a</td><td>scale factor </td></tr>
    <tr><td class="paramname">xU</td><td>Unconjugated input complex data array </td></tr>
    <tr><td class="paramname">xC</td><td>Conjugated input complex data array </td></tr>
    <tr><td class="paramname">y</td><td>Output complex data array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga53707938a6bc21c6e01f719a3fe51f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53707938a6bc21c6e01f719a3fe51f30">&#9670;&nbsp;</a></span>eblas_capMinMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eblas_capMinMax </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>xMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>xMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>capLo</em> = <code>-DBL_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>capHi</em> = <code>+DBL_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the minimum and maximum of a data array and optionally cap it from above and/or below. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Length of data array </td></tr>
    <tr><td class="paramname">x</td><td>Input data array, that might be modified if capLo or capHi are finite </td></tr>
    <tr><td class="paramname">xMin</td><td>On output, the minimum of the input data array </td></tr>
    <tr><td class="paramname">xMax</td><td>On output, the maximum of the input data array </td></tr>
    <tr><td class="paramname">capLo</td><td>If finite, cap the data array on output from below at this value (no capping for the default value) </td></tr>
    <tr><td class="paramname">capHi</td><td>If finite, cap the data array on output from above at this value (no capping for the default value) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3e6f244886dd30b195522884c18637f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e6f244886dd30b195522884c18637f2">&#9670;&nbsp;</a></span>eblas_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void eblas_copy </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a data array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type of the input and output arrays </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Destination data pointer </td></tr>
    <tr><td class="paramname">src</td><td>Source data pointer </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements of the data type T to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8d7f3fb6cf181094d3969a28f2d661f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d7f3fb6cf181094d3969a28f2d661f1">&#9670;&nbsp;</a></span>eblas_div()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ty , typename Tx &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void eblas_div </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tx *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ty *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Templated elementwise divide Y /= X for arrays X, Y. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ty</td><td>primiitive data-type for array Y </td></tr>
    <tr><td class="paramname">Tx</td><td>primiitive data-type for array X </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>number of elements in X and Y </td></tr>
    <tr><td class="paramname">X</td><td>pointer to the first element of array X </td></tr>
    <tr><td class="paramname">incX</td><td>stride along the X array </td></tr>
    <tr><td class="paramname">Y</td><td>pointer to the first element of array Y </td></tr>
    <tr><td class="paramname">incY</td><td>stride along the Y array (must be non-zero) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga749e567418ffb3a1c3b9de6774eeb493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga749e567418ffb3a1c3b9de6774eeb493">&#9670;&nbsp;</a></span>eblas_gather_zdaxpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eblas_gather_zdaxpy </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>Nindex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>conjx</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>w</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>conjw</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gather y += a * x(index) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Nindex</td><td>Length of index array </td></tr>
    <tr><td class="paramname">a</td><td>Scale factor (real) </td></tr>
    <tr><td class="paramname">index</td><td>0-based index array (with length at least Nindex) </td></tr>
    <tr><td class="paramname">x</td><td>Input array that is sampled with the index array (with length at least max(index)+1) </td></tr>
    <tr><td class="paramname">y</td><td>Output array that is sampled consecutively (with length at least Nindex) </td></tr>
    <tr><td class="paramname">conjx</td><td>If true, use conj(x) instead of x </td></tr>
    <tr><td class="paramname">w</td><td>Optional array that is sampled consecutively and multiplies x elementwise </td></tr>
    <tr><td class="paramname">conjw</td><td>If true, use conj(w) instead of w </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga77f427ab61421ff49e1a5e3f2e4bd5ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77f427ab61421ff49e1a5e3f2e4bd5ab">&#9670;&nbsp;</a></span>eblas_lincomb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eblas_lincomb </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a> &amp;&#160;</td>
          <td class="paramname"><em>sX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a> &amp;&#160;</td>
          <td class="paramname"><em>sY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elementwise linear combination Z = sX * X + sY * Y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Number of elements in X, Y and X </td></tr>
    <tr><td class="paramname">sX</td><td>Scale factor for input X </td></tr>
    <tr><td class="paramname">X</td><td>Data pointer for input X </td></tr>
    <tr><td class="paramname">incX</td><td>Pointer increment for input X </td></tr>
    <tr><td class="paramname">sY</td><td>Scale factor for input Y </td></tr>
    <tr><td class="paramname">Y</td><td>Data pointer for input Y </td></tr>
    <tr><td class="paramname">incY</td><td>Pointer increment for input Y </td></tr>
    <tr><td class="paramname">Z</td><td>Data pointer for input Z </td></tr>
    <tr><td class="paramname">incZ</td><td>Pointer increment for input Z </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga16b2911192a4dd45990e8d3c8749bc3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16b2911192a4dd45990e8d3c8749bc3c">&#9670;&nbsp;</a></span>eblas_mul()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ty , typename Tx &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void eblas_mul </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tx *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ty *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Templated elementwise multiply Y *= X for arrays X, Y. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ty</td><td>primiitive data-type for array Y </td></tr>
    <tr><td class="paramname">Tx</td><td>primiitive data-type for array X </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>number of elements in X and Y </td></tr>
    <tr><td class="paramname">X</td><td>pointer to the first element of array X </td></tr>
    <tr><td class="paramname">incX</td><td>stride along the X array </td></tr>
    <tr><td class="paramname">Y</td><td>pointer to the first element of array Y </td></tr>
    <tr><td class="paramname">incY</td><td>stride along the Y array (must be non-zero) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6920f2c3375ac67c6baf1af5c8043063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6920f2c3375ac67c6baf1af5c8043063">&#9670;&nbsp;</a></span>eblas_scatter_zdaxpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eblas_scatter_zdaxpy </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>Nindex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>conjx</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>w</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>conjw</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scatter y(index) += a * x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Nindex</td><td>Length of index array </td></tr>
    <tr><td class="paramname">a</td><td>Scale factor (real) </td></tr>
    <tr><td class="paramname">index</td><td>0-based index array (with length at least Nindex) </td></tr>
    <tr><td class="paramname">x</td><td>Input array that is sampled consecutively (with length at least Nindex) </td></tr>
    <tr><td class="paramname">y</td><td>Output array that is sampled with the index array (with length at least max(index)+1) </td></tr>
    <tr><td class="paramname">conjx</td><td>If true, use conj(x) instead of x </td></tr>
    <tr><td class="paramname">w</td><td>Optional array that is sampled consecutively and multiplies x elementwise </td></tr>
    <tr><td class="paramname">conjw</td><td>If true, use conj(w) instead of w </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae73590ae7d8bc5430e35a0eca6590b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae73590ae7d8bc5430e35a0eca6590b09">&#9670;&nbsp;</a></span>eblas_symmetrize() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eblas_symmetrize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>symmIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>symmMult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Symmetrize a complex array x with phase factors, using N n-fold equivalence classes in symmIndex (useful for space group symmetrization in reciprocal space) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Length of array x </td></tr>
    <tr><td class="paramname">n</td><td>Length of symmetry equivalence classes </td></tr>
    <tr><td class="paramname">symmIndex</td><td>Every consecutive set of n indices in this array forms an equivalence class </td></tr>
    <tr><td class="paramname">symmMult</td><td>Multiplicity per equivalence class (number of repetitions of each element in orbit) </td></tr>
    <tr><td class="paramname">phase</td><td>Phase factors corresponding to each entry in symmIndex </td></tr>
    <tr><td class="paramname">x</td><td>Data array to be symmetrized in place </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1a00682eceae2e0e80fd1d3a3fea409b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a00682eceae2e0e80fd1d3a3fea409b">&#9670;&nbsp;</a></span>eblas_symmetrize() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eblas_symmetrize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>symmIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>symmMult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmatrix3.html">matrix3</a>&lt;&gt; *&#160;</td>
          <td class="paramname"><em>rotSpin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structcomplex.html">complex</a> * &gt;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Symmetrize a quadruplet of complex arrays with phase factors, using N n-fold equivalence classes in symmIndex (useful for space group symmetrization of spin density matrices in reciprocal space) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Length of array x </td></tr>
    <tr><td class="paramname">n</td><td>Length of symmetry equivalence classes </td></tr>
    <tr><td class="paramname">symmIndex</td><td>Every consecutive set of n indices in this array forms an equivalence class </td></tr>
    <tr><td class="paramname">symmMult</td><td>Multiplicity per equivalence class (number of repetitions of each element in orbit) </td></tr>
    <tr><td class="paramname">phase</td><td>Phase factors corresponding to each entry in symmIndex </td></tr>
    <tr><td class="paramname">rotSpin</td><td>Cartesian pseudo-vector (eg. spin) rotations corresponding to each symmetry operation </td></tr>
    <tr><td class="paramname">x</td><td>Data array to be symmetrized in place </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9d2cefdcc0e49ab0781fab0609ef5d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d2cefdcc0e49ab0781fab0609ef5d74">&#9670;&nbsp;</a></span>eblas_symmetrize() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eblas_symmetrize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>symmIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Symmetrize an array x, using N n-fold equivalence classes in symmIndex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Length of array x </td></tr>
    <tr><td class="paramname">n</td><td>Length of symmetry equivalence classes </td></tr>
    <tr><td class="paramname">symmIndex</td><td>Every consecutive set of n indices in this array forms an equivalence class </td></tr>
    <tr><td class="paramname">x</td><td>Data array to be symmetrized in place </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga86241e74ed835c20636e5f67b22abf3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86241e74ed835c20636e5f67b22abf3b">&#9670;&nbsp;</a></span>eblas_zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void eblas_zero </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zero a data array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Number of elements to zero </td></tr>
    <tr><td class="paramname">x</td><td>Data pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8f28a65ff8c0f48d2d04129b16c4111d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f28a65ff8c0f48d2d04129b16c4111d">&#9670;&nbsp;</a></span>nrm2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double nrm2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>Generic 2-norm for complex types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab3b8ee5929a836d73ccf24bb582c46ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3b8ee5929a836d73ccf24bb582c46ef">&#9670;&nbsp;</a></span>removePhase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void removePhase </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>meanPhase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sigmaPhase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>rmsImagErr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a complex wavefunction to a real one with optimum phase choice Store the phase statistics before conversion in meanPhase and sigmaPhase and the relative rms imaginary part truncated during conversion in rmsImagErr (Useful for getting real wavefunctions in gamma point only calculations or <a class="el" href="classWannier.html" title="Compute Maximally-Localized Wannier Functions.">Wannier</a> functions) </p>

</div>
</div>
<a id="gacca8fc028f3136278b6087e0f30e30b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacca8fc028f3136278b6087e0f30e30b2">&#9670;&nbsp;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcomplex.html">complex</a> sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__DataStructures.html#ga2fdb293649df38d6a56b2404df9249a5">Tptr</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>Generic sum for complex types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
</div>
</body>
</html>
